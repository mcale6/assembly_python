assembly_go/LICENSE
---
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.


---
assembly_go/ReadMe.md
---
# Go Assembly Code

Go package to calculate Assembly Numbers for Molecules. 

# Build

Make sure `go` is installed, the instructions for that can be found on the (`golang docs`)[https://go.dev/doc/install]

Confirm you've installed `go` correctly by running `go version` (a version later than 1.15 should be shown)

after that building the command line tool is easy just run `go build cmd/app/main.go -o assembly`

# Usage

Currently basic usage is as follows - note flags (preceded by a dash) can be in any order

filename as argument at the end of the command, outputs assembly index only:

`./assembly my_mol.mol`

verbose flag will result in more detailed pathway output. In this usage, my_mol.mol must be at the end:

`./assembly -verbose my_mol.mol`

filename can also be passed as a flag - this takes priority over putting the filename at the end if both are done

`./assembly -file=my_mol.mol -verbose`

number of workers in the worker pool and the buffer size of the jobs queue. Currently defaults both to 100 (yet to test how optimal the default is).

`./assembly -file=my_mol.mol -workers=500 -buffer=500`

The -molfile flag defaults to true to read input as a mol file. Switch to false to read input as custom
graph txt file. This is a basic format that was used in testing and development as is simply 5 lines, 
those being name, list of vertex indices, list of associated edges (will be read in pairs, 
e.g. 1 2 2 3 is edges {1, 2} and {2, 3}), vertex colours, edge colours. Vertex and edge colours interpreted
as strings, delineated by spaces. If there are no vertex or edge colours, replace the corresponding
line with an exclamation mark "!"

```
Square graph (name - this line can be anything)
1 2 3 4 5
1 2 2 3 3 4 4 5
A B A B B
Red Blue Red Blue
```

`./assembly -file=my_graph.txt -molfile=false`

The `-log` flag is a boolean, and if present will log the pathway output to a file (default log.txt)

To specify a log file use e.g. `-logfile my_log_file.txt` (must also have log flag to do anything)

## Example
Here's an example with aspirin:

`./assembly file=aspirin.mol -verbose`

Which produces this output:

```
Running on file:  aspirin.mol
ORIGINAL GRAPH
+++++++++++++++
Vertices [0 1 2 3 4 5 6 7 8 9 10 11 12]
Edges [[0 1] [2 0] [0 3] [1 4] [5 2] [2 6] [3 10] [4 7] [7 5] [6 8] [6 9] [10 11] [10 12]]
VertexColours [C C C O C C C C O O C O C]
EdgeColours [double single single single double single single double single double single double single]
+++++++++++++++
PATHWAY
Pathway Graphs
======
Vertices [2 0 5]
Edges [[2 0] [5 2]]
VertexColours [C C C]
EdgeColours [single double]
======
======
Vertices [3 10 11 12]
Edges [[3 10] [10 11] [10 12]]
VertexColours [O C O C]
EdgeColours [single double single]
======
======
Vertices [13 1 14]
Edges [[13 1] [1 14]]
VertexColours [C C C]
EdgeColours [double single]
======
----------
Remnant Graph
Vertices [0 3 2 6 8 9 4 7 5]
Edges [[0 3] [2 6] [6 8] [6 9] [4 7] [7 5]]
VertexColours [C O C C O O C C C]
EdgeColours [single single double single double single]
----------
Duplicated Edges
[0 2]
[1 4 5]
[1 2]
+++++++++++++++

Assembly Index:  8
Time:  0.0449225
```

Sample build command from repo root

go build -o bin\assembly.exe GoAssembly/cmd/app


---
assembly_go/go.mod
---
module GoAssembly

go 1.16



---
assembly_go/go.sum
---
github.com/corona10/goimagehash v1.0.2 h1:pUfB0LnsJASMPGEZLj7tGY251vF+qLGqOgEP4rUs6kA=
github.com/corona10/goimagehash v1.0.2/go.mod h1:/l9umBhvcHQXVtQO1V6Gp1yD20STawkhRnnX0D1bvVI=
github.com/fogleman/gg v1.3.0 h1:/7zJX8F6AaYQc57WQCyN9cAIz+4bCJGO9B+dyW29am8=
github.com/fogleman/gg v1.3.0/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=
github.com/goccy/go-graphviz v0.0.9 h1:s/FMMJ1Joj6La3S5ApO3Jk2cwM4LpXECC2muFx3IPQQ=
github.com/goccy/go-graphviz v0.0.9/go.mod h1:wXVsXxmyMQU6TN3zGRttjNn3h+iCAS7xQFC6TlNvLhk=
github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 h1:DACJavvAHhabrF08vX0COfcOBJRhZ8lUbR+ZWIs0Y5g=
github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=
github.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=
github.com/nfnt/resize v0.0.0-20160724205520-891127d8d1b5 h1:BvoENQQU+fZ9uukda/RzCAL/191HHwJA5b13R6diVlY=
github.com/nfnt/resize v0.0.0-20160724205520-891127d8d1b5/go.mod h1:jpp1/29i3P1S/RLdc7JQKbRpFeM1dOBd8T9ki5s+AY8=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20200204104054-c9f3fb736b72/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/image v0.0.0-20200119044424-58c23975cae1 h1:5h3ngYt7+vXCDZCup/HkCQgW5XwmSvR/nA2JmJ0RErg=
golang.org/x/image v0.0.0-20200119044424-58c23975cae1/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=


---
assembly_go/cmd/app/main.go
---
package main

import (
	"GoAssembly/pkg/assembly"
	"flag"
	"fmt"
	"log"
	"os"
	"time"
)

type CommandLineOptions struct {
	inputFile *string
	molFile *bool
	logFile *string
	numWorkers *int
	bufferSize *int
	variant *string
	debug *bool
	verbose *bool
	log *bool
	pathway *bool
	tail []string
	}

func check(e error) {
	if e != nil {
		log.Fatal(e)
	}
}

// main executable will output assembly index and pathway to stdout and log file if selected in command line arguments
func main() {

	// command line arguments
	inputFile := flag.String("file", "", "the name of the input file")
	molFile := flag.Bool("molfile", true, "true if molfile, false if general graph file")
	logFile := flag.String("logfile", "log.txt", "the path to the log file")
	numWorkers := flag.Int("workers", 100, "the number of workers in the worker pool")
	bufferSize := flag.Int("buffer", 100, "the buffer size of the jobs queue")
	variant := flag.String("variant", "shortest", "the variant of the algorithm - currently only shortest implemented")
	debug := flag.Bool("debug", false, "additional logging - not currently used")
	verbose := flag.Bool("verbose", false, "stdout pathway information - if false, only assembly index output")
	log := flag.Bool("log", false, "log to file")
	pathway := flag.Bool("pathway", false, "the input file contains multiple graphs in the form of a starting pathway, e.g. an sdf file")

	flag.Parse()
	CLArgs := CommandLineOptions{
		inputFile,
		molFile,
		logFile,
		numWorkers,
		bufferSize,
		variant,
		debug,
		verbose,
		log,
		pathway,
		flag.Args(),
	}

	var logf *os.File
	var err error

	// set up log file
	if *CLArgs.log{
		logf, err = os.Create(*CLArgs.logFile)
		check(err)
		assembly.Logger.SetOutput(logf)
	}

	// get input  file
	var inFile string
	if *CLArgs.inputFile == "" {
		inFile = CLArgs.tail[0]
	} else {
		inFile = *CLArgs.inputFile
	}

	// Generate slice of Graphs. This will just contain the graph of the initial structure, unless a starting pathway is provided, in which
	// case it will contain the graphs in the pathway
	var fileGraph []assembly.Graph
	if *CLArgs.pathway{
		fileGraph = assembly.ParseSDFile(inFile, true)
	} else {
		if *CLArgs.molFile {
			fileGraph = append(fileGraph, assembly.MolColourGraph(inFile))
		} else {
			fileGraph = append(fileGraph, assembly.NewGraphOnlyFromFile(inFile))
		}
	}

	var pathways []assembly.Pathway
	start := time.Now()

	// Generate the output pathways. At present, the only variant implemented will return a single shortest pathway
	if *CLArgs.pathway{
		originalGraph, starterPathway := assembly.MolListToPathway(fileGraph, []assembly.Duplicates{})
		pathways = assembly.AssemblyPathway(originalGraph, starterPathway, *CLArgs.numWorkers, *CLArgs.bufferSize,*CLArgs.variant)
	} else {
		pathways = assembly.Assembly(fileGraph[0], *CLArgs.numWorkers, *CLArgs.bufferSize, *CLArgs.variant)
	}


	elapsed := time.Now().Sub(start)

	// calculate the assembly index from the pathways, and a string containing pathway details
	assemblyIndex := assembly.AssemblyIndex(&pathways[0], &fileGraph[0])
	assemblyString := assembly.AssemblyString(pathways, &fileGraph[0])

	// output assembly index and details to stdout
	if *CLArgs.verbose {
		fmt.Println("Running on file: ", inFile)

		fmt.Println(assemblyString)
		fmt.Println("Assembly Index: ", assemblyIndex)
		fmt.Println("Time: ", elapsed.Seconds())
	} else {
		fmt.Println(assemblyIndex)
	}

	// output assembly index and details to log file (if specified in command line arguments)
	if *CLArgs.log{
		assembly.Logger.Debug("Running on file: ", inFile)
		assembly.Logger.Debug(assemblyString)
		assembly.Logger.Debug("Assembly Index: ", assemblyIndex)
		assembly.Logger.Debug("Time: ", elapsed.Seconds())
	}
}


---
assembly_go/pkg/helpers/helpers.go
---
package helpers

import (
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
)

// Contains returns true if i is in slice l
func Contains(l []int, i int) bool {
	for _, v := range l {
		if v == i {
			return true
		}
	}
	return false
}

// ContainsStr returns true if i is in slice l
func ContainsStr(l []string, i string) bool {
	for _, v := range l {
		if v == i {
			return true
		}
	}
	return false
}

// MapUpdate updates a map from an int to a slice of ints
// if the k is in the map, v is appended to the slice, otherwise k is added to the map with value {v}
func MapUpdate(k int, v int, m map[int][]int) {

	if _, ok := m[k]; ok {
		m[k] = append(m[k], v)
	} else {
		m[k] = []int{v}
	}
}

// MapUpdateAppend updates a map from an int to a slice of ints
// similar to MapUpdate, but in this case v is []int. If k is in the map, the values of v are appended to m[k]
// and if not then the m[k] is set to be a copy of v
func MapUpdateAppend(k int, v []int, m map[int][]int) {
	if _, ok := m[k]; ok {
		m[k] = append(m[k], v...)
	} else {
		m[k] = make([]int, len(v))
		copy(m[k], v)
	}
}

// CopyAppend takes a slice of int and appends a copy of it to a slice of slices
func CopyAppend(sliceOfSlices [][]int, slice []int) [][]int {
	appendSlice := make([]int, len(slice))
	copy(appendSlice, slice)
	sliceOfSlices = append(sliceOfSlices, appendSlice)
	return sliceOfSlices
}

// CopyAppendSafe calls CopyAppend with a mutex wrapped around it
func CopyAppendSafe(sliceOfSlices [][]int, slice []int) [][]int {
	var mu sync.Mutex
	mu.Lock()
	appendSlice := make([]int, len(slice))
	copy(appendSlice, slice)
	sliceOfSlices = append(sliceOfSlices, appendSlice)
	mu.Unlock()
	return sliceOfSlices
}

// CopySliceOfSlices copies a slice of slices of ints
func CopySliceOfSlices(sliceOfSlices [][]int) [][]int {
	var newSliceOfSlices [][]int
	for _, s := range sliceOfSlices{
		newSliceOfSlices = CopyAppendSafe(newSliceOfSlices, s)
	}
	return newSliceOfSlices
}

// SortInnerIntList takes a slice of slices of ints and sorts the slices
func SortInnerIntList(l [][]int) {
	for _, item := range l {
		sort.Ints(item)
	}
}

// SortSliceOfSlices sorts a slice of int slices lexographically
func SortSliceOfSlices(l [][]int) {

	// first sort the slices themselves
	SortInnerIntList(l)

	sort.Slice(l, func(i1, i2 int) bool {
		return SliceCompare(l[i1], l[i2])
	})

}

// SliceCompare returns true if slice1 < slice2 in the first element that differs
func SliceCompare(slice1, slice2 []int) bool {
	if len(slice1) != len(slice2) {
		return len(slice1) < len(slice2) // sort first by length
	} else {
		for i := 0; i < len(slice1); i++ {
			if slice1[i] != slice2[i] {
				return slice1[i] < slice2[i] // then by first element that differs
			}
		}
	}
	return false // slices are the same
}

// SliceOfSlicesOverlap returns true if there are any ints duplicated within slice of slices, e.g. {{1,2,3}, {3,4,5}} returns true due to 3
func SliceOfSlicesOverlap(sliceOfSlices [][]int) bool {
	var alreadyFound []int
	for _, slice := range sliceOfSlices {
		for _, n := range slice {
			if Contains(alreadyFound, n) {
				return true
			}
			alreadyFound = append(alreadyFound, n)
		}
	}

	return false
}

// MaxIntSlice returns the maximum value in a slice of ints
func MaxIntSlice(inputSlice []int) int {
	max := 0
	for _, i := range inputSlice {
		if i > max {
			max = i
		}
	}
	return max
}

// TimeStamp returns a formatted string timestamp to use for test data file/folder names etc
func TimeStamp() string {
	t := time.Now()
	return t.Format("20060102150405")
}

func CreateDirectoryIfNotExists(dirName string, relative bool) error {

	var dir string

	if relative {
		dir = filepath.Join(".", dirName)
	} else {
		dir = dirName
	}
	err := os.MkdirAll(dir, os.ModePerm)

	return err
}

func FileNameWithoutExtension(fileName string) string {
	return strings.TrimSuffix(fileName, filepath.Ext(fileName))
}

func check(e error) {
	if e != nil {
		log.Fatal(e)
	}
}

func CreateFileIfNotExists(fileName string) *os.File {
	file, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatal(err)
	}
	return file
}

// IntInSliceOfSlices checks if a number is in any of a slice of slices. Returns true/false and index
// the number appears in if it does. If it appears in multiple lists, the index is that of the first
func IntInSliceOfSlices(sliceOfSlices [][]int, checkInt int) (bool, int){

	for i, slice := range sliceOfSlices{
		if Contains(slice, checkInt){
			return true, i
		}
	}

	return false, -1

}


---
assembly_go/pkg/helpers/helpers_test.go
---
package helpers

import (
	"log"
	"reflect"
	"testing"
)

func TestContains(t *testing.T) {
	var tests = []struct {
		list    []int
		item    int
		desired bool
	}{
		{[]int{1, 2, 3, 4, 5}, 1, true},
		{[]int{1, 2, 3, 4, 5}, 6, false},
		{[]int{}, 1, false},
	}
	for _, test := range tests {
		output := Contains(test.list, test.item)
		if output != test.desired {
			t.Errorf("Expected Contains(%v,%v) to be %v, got %v", test.list, test.item, test.desired, output)
		}
	}
}

func TestMapUpdate(t *testing.T) {
	var testMap = map[int][]int{
		1: {},
		2: {1},
	}

	var desiredMap = map[int][]int{
		1: {2, 3},
		2: {1, 2},
		3: {1, 2},
	}

	MapUpdate(1, 2, testMap)
	MapUpdate(1, 3, testMap)
	MapUpdate(2, 2, testMap)
	MapUpdate(3, 1, testMap)
	MapUpdate(3, 2, testMap)

	eq := reflect.DeepEqual(testMap, desiredMap)

	if !eq {
		t.Error("Test maps not equal to desired map after MapUpdate")
	}

}

func TestMapUpdateAppend(t *testing.T) {
	tests := []struct {
		m       map[int][]int
		k       int
		v       []int
		desired map[int][]int
	}{
		{
			map[int][]int{
				1: {},
			},
			1,
			[]int{1, 2, 3},
			map[int][]int{
				1: {1, 2, 3},
			},
		},
		{
			map[int][]int{
				1: {},
			},
			2,
			[]int{1, 2, 3},
			map[int][]int{
				1: {},
				2: {1, 2, 3},
			},
		},
		{
			map[int][]int{
				1: {1, 2, 3},
				2: {4, 5, 6},
			},
			2,
			[]int{7, 8, 9},
			map[int][]int{
				1: {1, 2, 3},
				2: {4, 5, 6, 7, 8, 9},
			},
		},
	}

	for _, tt := range tests {
		newMap := make(map[int][]int)
		for k, v := range tt.m {
			newMap[k] = make([]int, len(v))
			copy(newMap[k], v)
		}
		MapUpdateAppend(tt.k, tt.v, newMap)
		eq := reflect.DeepEqual(newMap, tt.desired)
		if !eq {
			t.Errorf("MapUpdateAppend error: appending %v: %v to %v, expected %v got %v ",
				tt.k, tt.v, tt.m, tt.desired, newMap)
		}
	}
}

func TestSortInnerIntList(t *testing.T) {
	tests := []struct {
		l      [][]int
		sorted [][]int
	}{
		{
			[][]int{{1}, {2}, {3}, {4}, {5}},
			[][]int{{1}, {2}, {3}, {4}, {5}},
		},
		{
			[][]int{{1, 2, 3}},
			[][]int{{1, 2, 3}},
		},
		{
			[][]int{{1, 3, 2}},
			[][]int{{1, 2, 3}},
		},
		{
			[][]int{{4, 6, 5}, {1, 2, 3}},
			[][]int{{4, 5, 6}, {1, 2, 3}},
		},
		{
			[][]int{{1, 3, 3, 2}, {4, 6, 5}},
			[][]int{{1, 2, 3, 3}, {4, 5, 6}},
		},
	}

	for _, tt := range tests {
		var sorted [][]int

		for _, item := range tt.l {
			copyItem := make([]int, len(item))
			copy(copyItem, item)
			sorted = append(sorted, copyItem)
		}

		SortInnerIntList(sorted)

		eq := reflect.DeepEqual(sorted, tt.sorted)

		if !eq {
			t.Errorf("SortInnerIntList error, sorting %v, expected %v, got %v", tt.l, tt.sorted, sorted)
		}
	}
}

func TestSliceCompare(t *testing.T) {
	tests := []struct {
		slice1  []int
		slice2  []int
		compare bool
	}{
		{
			[]int{1, 2, 3},
			[]int{1, 2, 3},
			false,
		},
		{
			[]int{1, 2},
			[]int{1, 2, 3},
			true,
		},
		{
			[]int{1, 2, 3},
			[]int{1, 2},
			false,
		},
		{
			[]int{1, 2, 3},
			[]int{2, 3, 4},
			true,
		},
		{
			[]int{1, 3, 5},
			[]int{1, 3, 4},
			false,
		},
		{
			[]int{6, 7, 8},
			[]int{1, 3, 4},
			false,
		},
	}

	for _, tt := range tests {
		compare := SliceCompare(tt.slice1, tt.slice2)
		if compare != tt.compare {
			t.Errorf("SliceCompare error, checking if %v before %v, expected %v, got %v",
				tt.slice1, tt.slice2, tt.compare, compare)
		}
	}
}

func TestSortSliceOfSlices(t *testing.T) {
	tests := []struct {
		sliceOfSlices [][]int
		sorted        [][]int
	}{
		{
			[][]int{{1, 2, 3}, {4, 5, 6}},
			[][]int{{1, 2, 3}, {4, 5, 6}},
		},
		{
			[][]int{{4, 5, 6}, {1, 2, 3}},
			[][]int{{1, 2, 3}, {4, 5, 6}},
		},
		{
			[][]int{{4, 6, 5}, {1, 3, 2}},
			[][]int{{1, 2, 3}, {4, 5, 6}},
		},
		{
			[][]int{{4, 6, 5}, {1, 3, 2}, {1, 2}},
			[][]int{{1, 2}, {1, 2, 3}, {4, 5, 6}},
		},
	}

	for _, tt := range tests {
		var sorted [][]int

		for _, item := range tt.sliceOfSlices {
			copyItem := make([]int, len(item))
			copy(copyItem, item)
			sorted = append(sorted, copyItem)
		}

		SortSliceOfSlices(sorted)

		eq := reflect.DeepEqual(sorted, tt.sorted)
		if !eq{
			t.Errorf("SortSliceOfSlices Error, sorting %v, expected %v, got %v", tt.sliceOfSlices, tt.sorted, sorted)
		}
	}
}

func TestSliceOfSlicesOverlap(t *testing.T) {
	tests := []struct{
		sliceOfSlices [][]int
		expected bool
	}{
		{
			[][]int{},
			false,
		},
		{
			[][]int{{1, 2, 3}},
			false,
		},
		{
			[][]int{{1, 2, 3}, {4, 5, 6}},
			false,
		},
		{
			[][]int{{1, 2, 3}, {3, 5, 6}},
			true,
		},
		{
			[][]int{{1, 2, 2}, {4, 5, 6}},
			true,
		},
	}
	for i, tt := range tests{
		result := SliceOfSlicesOverlap(tt.sliceOfSlices)
		if !(result == tt.expected){
			t.Errorf("Error in test %v, input %v, expected %v, got %v", i, tt.sliceOfSlices, tt.expected, result)
		}
	}
}


func TestCreateDirectoryIfNotExists(t *testing.T) {

	err := CreateDirectoryIfNotExists("testdata/test_directory", true)
	check(err)

}

func TestCreateFileIfNotExists(t *testing.T) {
	file := CreateFileIfNotExists("testdata/tmp.txt")
	log.SetOutput(file)
	log.Println("test log")
}

func TestCopySliceOfSlices(t *testing.T) {
	tests := []struct{
		sliceOfSlices [][]int
		newSliceOfSlices [][]int
	}{

		{
			[][]int{{1}},
			[][]int{{1}},
		},
		{
			[][]int{{1, 2, 3}},
			[][]int{{1, 2, 3}},
		},
		{
			[][]int{{1, 2, 3}, {4, 5, 6}},
			[][]int{{1, 2, 3}, {4, 5, 6}},
		},
		{
			[][]int{{1},{2},{3}},
			[][]int{{1},{2},{3}},
		},
	}

	for _, tt := range tests{
		newSliceOfSlices := CopySliceOfSlices(tt.sliceOfSlices)
		if !reflect.DeepEqual(tt.newSliceOfSlices, newSliceOfSlices){
			t.Errorf("CopySliceOfSlices error, slice %v, expected %v, got %v", tt.sliceOfSlices, tt.newSliceOfSlices, newSliceOfSlices)
		}
		// check modifying original
		tt.newSliceOfSlices[0] = []int{-1}
		if reflect.DeepEqual(tt.newSliceOfSlices, newSliceOfSlices){
			t.Errorf("CopySliceOfSlices error after modifying original, slice %v, modified slice %v, new slice altered %v", tt.sliceOfSlices, tt.newSliceOfSlices, newSliceOfSlices)
		}
	}
}

func TestIntInSliceOfSlices(t *testing.T) {
	tests := []struct{
		sliceOfSlices [][]int
		checkInt int
		contains bool
		index int
	}{
		{
			[][]int{{1, 2}, {3, 4, 5}},
			1,
			true,
			0,

		},
		{
			[][]int{{1, 2}, {3, 4, 5}},
			3,
			true,
			1,

		},
		{
			[][]int{{1, 2}, {3, 4, 5}},
			2,
			true,
			0,

		},
		{
			[][]int{{1, 2}, {3, 4, 5}},
			5,
			true,
			1,

		},
		{
			[][]int{{1, 2, 5}, {3, 4, 5}},
			5,
			true,
			0,

		},
		{
			[][]int{{1, 2}, {3, 4, 5}},
			6,
			false,
			-1,

		},
	}

	for _, tt := range tests{

		contains, index := IntInSliceOfSlices(tt.sliceOfSlices, tt.checkInt)
		chkContains := contains == tt.contains
		chkIndex := index == tt.index

		if !(chkContains && chkIndex){
			t.Errorf("IntInSliceOfSlices error, slices %v, int %v, expected %v, %v, got %v, %v",
				tt.sliceOfSlices, tt.checkInt, tt.contains, tt.index, contains, index)
		}


	}
}

---
assembly_go/pkg/helpers/logs.txt
---
2021/09/28 14:40:01 test log
2021/09/28 14:43:38 test log
2021/09/28 15:16:52 test log


---
assembly_go/pkg/helpers/testdata/tmp.txt
---
2021/09/28 15:17:53 test log


---
assembly_go/pkg/assembly/allsubgraphs.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
)

// NOTE: These are mot used in the main assembly algorithm. They are retained for use in future functionality.
// Path tracing algorithm implementation for all subgraphs.
// from Automatic Enumeration of All Connected Subgraphs, Rucker &  Rucker, 2000
// These functions are not present in the main assembly algorithm, as the algorithms are written into the
// architecture of the assembly functions. They can be used to check subgraphs though.

// AllSubgraphsToChan is the main subraph enumeration algorithm used, returning the subgraphs into a channel
// returns the count of the number of subgraphs, and an error
// countMode determines if the individual subgraphs are returned or not
func AllSubgraphsToChan(g *Graph, subgraphChan chan []int, subCountChan chan int, countMode bool) {
	var chans []chan [][]int
	var intChans []chan int
	defer close(subgraphChan)
	defer close(subCountChan)

	// initialise list of channels and run for all subgraphs containing the given edge, and those with higher indices
	for i := range g.Edges {
		chans = append(chans, make(chan [][]int, 1000))
		intChans = append(intChans, make(chan int, 1000))
		go AllSubsOnEdge(g, i, chans[i], intChans[i], countMode)
	}

	for i := 0; i < len(chans); i++ {

		// put all the subgraphs in the output channel if we are not in countMode
		edgeSubs := <-chans[i]
		if !countMode {
			for _, sub := range edgeSubs {
				subgraphChan <- sub
			}
		}

		// put the subgraph count for this edge in the subcount channel
		thisSubCount := <-intChans[i]
		subCountChan <- thisSubCount
	}

}

// SubgraphCount returns the number of subgraphs of a graph g as an integer
func SubgraphCount(g *Graph) int {
	_, subCount, _  := AllSubgraphs(g, true)
	return subCount
}

// MolSubgraphCount returns a count of all subgraphs of a molfile or mol block
func MolSubgraphCount(mol string, molBlock bool) int {
	var g Graph
	if molBlock{
		g = MolBlockColourGraph(mol)
	} else {
		g = MolColourGraph(mol)
	}
	return SubgraphCount(&g)
}

// AllSubgraphs returns all subgraphs as edge lists. If countMode is true, this will only return the count of the number of subgraphs,
// and will return nil for the list of subgraphs
func AllSubgraphs(g *Graph, countMode bool) ([][]int, int, error) {

	var edgeSubgraphs [][]int = nil
	subCount := 0
	var chans []chan [][]int
	var intChans []chan int

	for i := range g.Edges {
		chans = append(chans, make(chan [][]int))
		intChans = append(intChans, make(chan int))
		go AllSubsOnEdge(g, i, chans[i], intChans[i], countMode)
	}

	for i := 0; i < len(chans); i++ {
		eSub := <-chans[i]
		thisSubCount := <-intChans[i]
		edgeSubgraphs = append(edgeSubgraphs, eSub...)
		subCount += thisSubCount
	}

	return edgeSubgraphs, subCount, nil

}

// AllSubsOnEdge is called from AllSubgraphs to return all subgraphs that include a particular edge, and
// edges with higher indices
func AllSubsOnEdge(g *Graph, e int, c chan [][]int, cInt chan int, countMode bool) {

	edgeAdjacencies, sub, subCount, edgeSubgraphs, forbidden, forbiddenSize := InitialiseSubsOnEdge(g, e)

	for len(sub) != 0 {
		edgeSubgraphs, subCount, sub, forbidden, forbiddenSize = NextSubgraph(edgeSubgraphs, subCount, sub, forbidden, forbiddenSize, edgeAdjacencies, countMode)
	}

	if !countMode {
		c <- edgeSubgraphs
	} else {
		c <- nil
	}

	cInt <- subCount
}

// InitialiseSubsOnEdge sets up initial values for the AllSubsOnEdge function
func InitialiseSubsOnEdge(g *Graph, e int) (map[int][]int, []int, int, [][]int, map[int]bool, map[int]int) {
	edgeAdjacencies := g.EdgeAdjacencies() // map of which edges are adjacent, maps edge index to slice of edge indices
	forbidden := make(map[int]bool)        // map for whether a edge is forbidden
	forbiddenSize := make(map[int]int)     // map of the size of the list an edge was forbidden from
	var sub []int                          // the current subgraph under construction
	var edgeSubgraphs [][]int

	modifyEdgeAdjacencies(edgeAdjacencies, e) // remove edges with index <= e

	sub = []int{e}                                             // sub starts with just the current edge
	subCount := 1                                              // Initially just the one sub (current edge)
	edgeSubgraphs = helpers.CopyAppendSafe(edgeSubgraphs, sub) // current edge only is a valid subgraph, so add to list

	return edgeAdjacencies, sub, subCount, edgeSubgraphs, forbidden, forbiddenSize
}

// NextSubgraph takes the current subgraphs, subgraph count, forbidden list, forbidden size list,
// and returns the updated version for the next step in the path
func NextSubgraph(edgeSubgraphs [][]int, subCount int, sub []int, forbidden map[int]bool,
	forbiddenSize map[int]int, edgeAdjacencies map[int][]int, countMode bool) ([][]int, int, []int, map[int]bool, map[int]int) {
	// find a non-forbidden neighbour
	neighbour, found := nonForbiddenNeighbour(sub, edgeAdjacencies, forbidden)

	if found {

		// if a neighbour is available add it to sub
		subCount++
		sub = append(sub, neighbour)
		if !countMode {
			edgeSubgraphs = helpers.CopyAppendSafe(edgeSubgraphs, sub)
		}

	} else {
		// forbid the last item added, remove it, and update forbidden lists
		thisForbidSize := len(sub)
		thisForbid := sub[len(sub)-1]                                      // item to forbid
		sub = sub[:len(sub)-1]                                             // pop the forbidden element out
		forbidUpdate(thisForbid, thisForbidSize, forbidden, forbiddenSize) // update forbidden lists

	}

	return edgeSubgraphs, subCount, sub, forbidden, forbiddenSize
}

// strips out any edges in edgeAdj that are lower in index than v
func modifyEdgeAdjacencies(edgeAdj map[int][]int, e int) {
	for k := range edgeAdj {
		if k < e {
			delete(edgeAdj, k)
		} else {
			for i := 0; i < len(edgeAdj[k]); i++ {
				if edgeAdj[k][i] < e {
					edgeAdj[k] = append(edgeAdj[k][:i], edgeAdj[k][i+1:]...)
					i--
				}
			}
		}
	}
}


---
assembly_go/pkg/assembly/allsubgraphs_test.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
	"fmt"
	"reflect"
	"testing"
)


func TestAllSubsPTParallel(t *testing.T) {
	tests := []struct {
		g         Graph
		countMode bool
		subGraphs [][]int
		subCount  int
	}{
		{
			// graph with two vertices and one edge between
			NewGraph([]int{1, 2}, [][2]int{{1, 2}}),
			false,
			[][]int{{0}},
			1,
		},
		{
			// graph with two vertices and one edge, countMode so should return no subgraphs
			NewGraph([]int{1, 2}, [][2]int{{1, 2}}),
			true,
			nil,
			1,
		},
		{
			// graph with two vertices and one edge between
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}, {3, 1}}),
			false,
			[][]int{{0}, {1}, {2}, {0, 1}, {1, 2}, {0, 2}, {0, 1, 2}},
			7,
		},
		{
			// triangle graph
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}, {3, 1}}),
			true,
			nil,
			7,
		},
		{
			// disconnected graph 0-1-2 3-4
			NewGraph([]int{0, 1, 2, 3, 4}, [][2]int{{0, 1}, {1, 2}, {3, 4}}),
			false,
			[][]int{{0}, {1}, {2}, {0, 1}},
			4,
		},
		{
			// disconnected graph 0-1-2 triangle plus 3-4-5 linear
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {0, 2}, {3, 4}, {4, 5}}),
			false,
			[][]int{{0}, {1}, {2}, {3}, {4}, {0, 1}, {1, 2}, {2, 0}, {0, 1, 2}, {3, 4}},
			10,
		},
		{
			// aspirin has 579 subgraphs
			MolColourGraph("testdata/aspirin.mol"),
			true,
			nil,
			579,
		},
	}

	for _, tt := range tests {
		subGraphs, subCount, err := AllSubgraphs(&tt.g, tt.countMode)
		check(err)
		helpers.SortSliceOfSlices(subGraphs)
		helpers.SortSliceOfSlices(tt.subGraphs)
		eq1 := reflect.DeepEqual(subGraphs, tt.subGraphs)
		eq2 := subCount == tt.subCount
		if !(eq1 && eq2) {
			errMessage := "Error in AllSubgraphs\n"
			errMessage += fmt.Sprintf("Subgraphs expected %v got %v\n", tt.subGraphs, subGraphs)
			errMessage += fmt.Sprintf("Subgraph count expected %v got %v\n", tt.subCount, subCount)
			t.Error(errMessage)
		}
	}
}


func TestGetAllSubgraphs(t *testing.T) {
	tests := []struct {
		g         Graph
		countMode bool
		subGraphs [][]int
		subCount  int
	}{
		{
			// graph with two vertices and one edge between
			NewGraph([]int{1, 2}, [][2]int{{1, 2}}),
			false,
			[][]int{{0}},
			1,
		},
		{
			// graph with two vertices and one edge, countMode so should return no subgraphs
			NewGraph([]int{1, 2}, [][2]int{{1, 2}}),
			true,
			nil,
			1,
		},
		{
			// graph with two vertices and one edge between
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}, {3, 1}}),
			false,
			[][]int{{0}, {1}, {2}, {0, 1}, {1, 2}, {0, 2}, {0, 1, 2}},
			7,
		},
		{
			// triangle graph
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}, {3, 1}}),
			true,
			nil,
			7,
		},
		{
			// disconnected graph 0-1-2 3-4
			NewGraph([]int{0, 1, 2, 3, 4}, [][2]int{{0, 1}, {1, 2}, {3, 4}}),
			false,
			[][]int{{0}, {1}, {2}, {0, 1}},
			4,
		},
		{
			// disconnected graph 0-1-2 triangle plus 3-4-5 linear
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {0, 2}, {3, 4}, {4, 5}}),
			false,
			[][]int{{0}, {1}, {2}, {3}, {4}, {0, 1}, {1, 2}, {2, 0}, {0, 1, 2}, {3, 4}},
			10,
		},
		{
			// aspirin has 579 subgraphs
			MolColourGraph("testdata/aspirin.mol"),
			true,
			nil,
			579,
		},
	}

	for _, tt := range tests {

		subgraphChan := make(chan []int)
		subCountChan := make(chan int)
		var subGraphs [][]int
		subCount := 0


		go AllSubgraphsToChan(&tt.g, subgraphChan, subCountChan, tt.countMode)


		for{
			select {
				case sub, ok := <- subgraphChan:
					if ok{
						subGraphs = append(subGraphs, sub)
					} else {
						subgraphChan = nil
					}
				case count, ok := <- subCountChan:
					if ok{
						subCount += count
					} else {
						subCountChan = nil
					}
			}

			if subgraphChan == nil && subCountChan == nil{
				break
			}

		}





		// subGraphs, subCount, err := AllSubgraphs(&tt.g, tt.countMode)
		helpers.SortSliceOfSlices(subGraphs)
		helpers.SortSliceOfSlices(tt.subGraphs)
		eq1 := reflect.DeepEqual(subGraphs, tt.subGraphs)
		eq2 := subCount == tt.subCount
		if !(eq1 && eq2) {
			errMessage := "Error in AllSubgraphs\n"
			errMessage += fmt.Sprintf("Subgraphs expected %v got %v\n", tt.subGraphs, subGraphs)
			errMessage += fmt.Sprintf("Subgraph count expected %v got %v\n", tt.subCount, subCount)
			t.Error(errMessage)
		}
	}
}

func TestSubgraphCount(t *testing.T) {
	tests := []struct{
		g Graph
		subCount int
	}{
		{
			MolColourGraph("testdata/aspirin.mol"),
			579,
		},
	}

	for _, tt := range tests{
		subCount := SubgraphCount(&tt.g)
		if subCount != tt.subCount{
			t.Errorf("Subgraph count expected %v got %v\n", tt.subCount, subCount)
		}
	}
}

func TestMolSubgraphCount(t *testing.T) {
	tests := []struct{
		mol string
		molBlock bool
		subCount int
	}{
		{
			"testdata/aspirin.mol",
			false,
			579,
		},
	}

	for _, tt := range tests{
		subCount := MolSubgraphCount(tt.mol, tt.molBlock)
		if subCount != tt.subCount{
			t.Errorf("MolSubgraphCount expected %v got %v\n", tt.subCount, subCount)
		}
	}
}

func TestAspirinSubs(t *testing.T){
	aspirin := MolColourGraph("testdata/aspirin.mol")
	subs, _, _ := AllSubgraphs(&aspirin, false)
	for _, s := range subs{
		fmt.Println(s)
	}
}

---
assembly_go/pkg/assembly/assemblycommon.go
---
package assembly

// this file contains functions common to both the serial and parallel implementations of the assembly algorithms

import (
	"GoAssembly/pkg/helpers"
	"fmt"
	"log"
	"math"
	"reflect"
	"sync"
)

// Pathway contains all information representing an assembly pathway. Pathway.pathway is a list of graphs that represent duplicated structures
// within the original graph object, and Pathway.duplicates is the related edge indices of those duplicated graphs with respect to the original graph (TODO: check this)
// Pathway.remnant is the remaining structure once duplicates have been removed / separated out. Pathway does not contain the original graph, which is also
// required for meaningful calculations, such as the assembly index.
type Pathway struct {
	pathway    []Graph
	remnant    Graph
	duplicates []Duplicates
	atomEquivalents [][]int
}

// NewStartingPathway returns a pathway with only the remnant and no duplicates etc
func NewStartingPathway(graph Graph) Pathway{
	var pathway []Graph
	var duplicates []Duplicates
	var atomEquivalents [][]int
	return NewPathway(pathway, graph, duplicates, atomEquivalents)

}

func NewPathway(pathway []Graph, remnant Graph, duplicates []Duplicates, atomEquivalents [][]int) Pathway{
	return Pathway{
		pathway,
		remnant,
		duplicates,
		atomEquivalents,
	}
}

// Duplicates details the bonds involved in pahtway duplicates. Left will be a duplicate in the pathway, whereas right will be part of the remnant
// but broken off from the rest
type Duplicates struct{
	left [][2]int
	right [][2]int
}

// check is a basic error checking function
func check(e error) {
	if e != nil {
		log.Fatal(e)
	}
}

// PathwayStepsSaved checks the total steps saved on a pathway by looking at the size of the duplicates
// each duplicate can save the number of edges/nodes in it (depending on edgeMode) minus 1. This is because all those edges/nodes
// would otherwise need to be added individually. The -1 is because you would still need one step to join the duplicate structure.
// Currently edgemode should always be true, unless and until vertex based assembly is implemented
func PathwayStepsSaved(pathway *Pathway, edgeMode bool) int {
	stepsSaved := 0

	for i := 0; i < len(pathway.pathway); i++ {
		if edgeMode {
			stepsSaved += len(pathway.pathway[i].Edges) - 1
		} else {
			stepsSaved += len(pathway.pathway[i].Vertices) - 1
		}
	}

	return stepsSaved
}


// BestPathwayUpdate checks a pathway against the best pathway found so far. If the new pathway has more steps saved, it replaces bestPathway
func BestPathwayUpdate(bestPathway *Pathway, newPathway *Pathway) {

	var mutex = &sync.Mutex{}
	mutex.Lock()
	bestStepsSaved := PathwayStepsSaved(bestPathway, true)
	newStepsSaved := PathwayStepsSaved(newPathway, true)
	if newStepsSaved > bestStepsSaved {
		*bestPathway = *newPathway
	}
	mutex.Unlock()

}


// PathwayEqual tests if two pathways are identical. Mainly used for testing and development
// Graphs are tested for equality (automorphism) not isomorphism
// TODO: needs to be updated for new duplicates objects
func PathwayEqual(pathwayLeft *Pathway, pathwayRight *Pathway) bool {

	if len(pathwayLeft.pathway) != len(pathwayRight.pathway) || len(pathwayLeft.duplicates) != len(pathwayRight.duplicates) {
		return false
	}

	if !GraphEquals(&pathwayLeft.remnant, &pathwayRight.remnant) {
		return false
	}

	if !reflect.DeepEqual(pathwayLeft.duplicates, pathwayRight.duplicates) {
		return false
	}

	for i := 0; i < len(pathwayLeft.pathway); i++ {
		if !GraphEquals(&pathwayLeft.pathway[i], &pathwayRight.pathway[i]) {
			return false
		}
	}

	return true
}

// CopyPathway returns a full copy of a pathway
func CopyPathway(pathway *Pathway) Pathway {
	newGraphs := make([]Graph, 0)
	for _, g := range pathway.pathway {
		newGraphs = append(newGraphs, CopyGraph(&g))
	}


	newDuplicates := CopyDuplicates(pathway.duplicates)
	newRemnant := CopyGraph(&pathway.remnant)
	newAtomEquivalents := helpers.CopySliceOfSlices(pathway.atomEquivalents)

	return NewPathway(newGraphs, newRemnant, newDuplicates, newAtomEquivalents)
}


// CopyDuplicates returns a copy of a duplicates list
func CopyDuplicates(inputDuplicates []Duplicates) []Duplicates {
	var outputDuplicates []Duplicates
	for _, d := range inputDuplicates{
		newLeft := CopyEdgeList(d.left)
		newRight := CopyEdgeList(d.right)
		newDuplicate := Duplicates{newLeft, newRight}
		outputDuplicates = append(outputDuplicates, newDuplicate)
	}
	return outputDuplicates
}

// CopyEdgeList returns a copy of an input edge list
func CopyEdgeList(inputList [][2]int) [][2]int{
	var outputList [][2]int
	for _, edge := range inputList{
		p := [2]int{}
		p[0] = edge[0]
		p[1] = edge[1]
		outputList = append(outputList, p)
	}
	return outputList
}


// PathwayPrint prints full pathway information to stdout
func PathwayPrint(pathway *Pathway) {
	fmt.Println(PathwayString(pathway))
}

// PathwayPrintLog outputs full pathway information to the logger
func PathwayPrintLog(pathway *Pathway) {
	Logger.Debug(PathwayString(pathway))
}

// PathwayString outputs pathway information as a string
func PathwayString(pathway *Pathway) string {
	outString := "Pathway Graphs\n"
	for _, g := range pathway.pathway {
		outString += "======\n"
		outString += GraphPrint(&g) + "\n"
		outString += "======\n"
	}

	outString += "----------\n"
	outString += "Remnant Graph\n"
	outString += GraphPrint(&pathway.remnant) + "\n"
	outString += "----------\n"

	outString += "Duplicated Edges\n"
	for _, e := range pathway.duplicates {
		outString += fmt.Sprintf("%v\n", e)
	}
	outString +="+++++++++++++++\n"
	outString +="###############\n"
	outString += "Atom Equivalents\n"
	for _, e := range pathway.atomEquivalents{
		outString += fmt.Sprintf("%v\n", e)
	}
	outString +="###############\n"

	return outString
}

// AssemblyString returns a string with details of the original graph and pathway
func AssemblyString(pathways []Pathway, originalGraph *Graph) string {
	outString := "ORIGINAL GRAPH\n"
	outString += "+++++++++++++++\n"
	outString += GraphPrint(originalGraph) + "\n"
	outString += "+++++++++++++++\n"
	outString += "PATHWAY\n"

	for _, p := range pathways {
		outString += PathwayString(&p)
	}

	return outString
}

// AssemblyIndex returns the integer assembly index of the pathway, which is the max assembly index for originalGraph (number of edges - 1)
// minus the total steps saved through all the duplicates
func AssemblyIndex(pathway *Pathway, originalGraph *Graph) int {

	index := len(originalGraph.Edges) - 1
	index -= PathwayStepsSaved(pathway, true)
	return index

}

// forbidUpdate adds thisForbid to the forbidden list, updates forbiddenSize, and un-forbids any edges
// that have forbiddenSize > thisForbidSize. This function is part of the process of finding all subgraphs
func forbidUpdate(thisForbid int, thisForbidSize int, forbidden map[int]bool, forbiddenSize map[int]int) {
	for k, v := range forbiddenSize {
		if v > thisForbidSize {
			forbidden[k] = false
		}
	}
	forbidden[thisForbid] = true
	forbiddenSize[thisForbid] = thisForbidSize
}

// nonForbiddenNeighbour returns a non-forbidden neighbour of a subgraph (where a subgraph is a slice of int).
// This is part of the process of finding all subgraphs
func nonForbiddenNeighbour(sub []int, edgeAdjacencies map[int][]int, forbidden map[int]bool) (int, bool) {
	for _, e := range sub {
		for _, adj := range edgeAdjacencies[e] {
			if !forbidden[adj] && !helpers.Contains(sub, adj) {
				return adj, true
			}
		}
	}
	return -1, false
}

// BestAssemblyIndex returns the best possible assembly index of a pathway, based on the maximum possible
// steps saved on the remnant graph. This is used to bound the assembly process
func BestAssemblyIndex(g *Graph, pathway *Pathway) int {
	return AssemblyIndex(pathway, g) - MaxStepsSaved(pathway)
}

// MaxStepsSaved returns the maximum possible additional steps that could be saved within the remnant portion of a
// pathway. This is based on the assuming that each connected component remaining in the remnant can be constructed in the
// shortest possible way, which is bounded by the log base 2 of the number of edges (i.e. repeatedly duplicating an structure,
// from 1 edge, to 2, to 4, to 8 etc.
func MaxStepsSaved(pathway *Pathway) int {
	connectedComponentEdges := ConnectedComponentEdges(&pathway.remnant)
	maxStepsSaved := 0

	for _, c := range connectedComponentEdges {
		numEdges := len(c)
		naiveMA := numEdges - 1
		bestMA := int(math.Floor(math.Log2(float64(numEdges))))
		bestStepsSaved := naiveMA - bestMA
		maxStepsSaved += bestStepsSaved
	}

	return maxStepsSaved

}

// UpdateAtomEquivalents uses the vertexMap created in RecombineGraphs to update the pathway list of atom equivalents
func UpdateAtomEquivalents(pathway *Pathway, vertexMap map[int]int){
	for originalInt, newInt := range vertexMap{
		if newInt != originalInt {
			contains, index := helpers.IntInSliceOfSlices(pathway.atomEquivalents, originalInt)

			if contains {
				pathway.atomEquivalents[index] = append(pathway.atomEquivalents[index], newInt)
			} else {
				pathway.atomEquivalents = append(pathway.atomEquivalents, []int{originalInt, newInt})
			}
		}
	}
}



---
assembly_go/pkg/assembly/assemblycommon_test.go
---
package assembly

import (
	"reflect"
	"testing"
)

func TestPathwayStepsSaved(t *testing.T) {
	tests := []struct {
		pathway    Pathway
		edgeMode   bool
		stepsSaved int
	}{
		{
			// remnant and duplicated within the Pathway struct shouldn't make any difference
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{}, // not needed for this test
				[][]int{},
			},
			false,
			5,
		},
	}
	for i, tt := range tests {
		stepsSaved := PathwayStepsSaved(&tt.pathway, tt.edgeMode)
		if stepsSaved != tt.stepsSaved {
			t.Errorf("TestPathwayStepsSaved Error in test %v\nInput pathway %v\nExpected %v, Got %v",
				i, tt.pathway, tt.stepsSaved, stepsSaved)
		}
	}
}

func TestBestPathwayUpdate(t *testing.T) {
	tests := []struct {
		bestPathway Pathway
		newPathway  Pathway
		replace     bool
	}{
		{
			// Same Pathway Throughout
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			false,
		},
		{
			// Worse new pathway
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			false,
		},
		{
			// Better new pathway
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			true,
		},
	}

	_ = tests
	for i, tt := range tests {
		bestPathwayCopy := CopyPathway(&tt.bestPathway)
		BestPathwayUpdate(&tt.bestPathway, &tt.newPathway)

		eq := false
		if tt.replace {
			eq = PathwayEqual(&tt.bestPathway, &tt.newPathway)
		} else {
			eq = PathwayEqual(&tt.bestPathway, &bestPathwayCopy)
		}

		if !eq {
			t.Errorf("BestPathwayCopy error in test %v\nOriginal Best Pathway %v\nNew Pathway %v\nNew Best Pathway %v\nShould have been replaced %v",
				i, bestPathwayCopy, tt.newPathway, tt.bestPathway, tt.replace)
		}

	}
}

func TestPathwayEqual(t *testing.T) {
	tests := []struct {
		pathwayLeft  Pathway
		pathwayRight Pathway
		equal        bool
	}{
		{
			// identical pathways
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			true,
		},
		{
			// graphs differ
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			false,
		},
		{
			// duplicates differ
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			false,
		},
		{
			// remnant differs
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				[]Duplicates{},
				[][]int{},
			},
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				},
				NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				[]Duplicates{},
				[][]int{},
			},
			false,
		},
	}

	for i, tt := range tests {
		equal := PathwayEqual(&tt.pathwayLeft, &tt.pathwayRight)
		if equal != tt.equal {
			t.Errorf("PathwayEqual error in test %v\nPathway Left %v\nPathway Right %v\nExpected equality %v\nGot equality %v",
				i, tt.pathwayLeft, tt.pathwayRight, tt.equal, equal)
		}
	}

}

func TestCopyPathway(t *testing.T) {
	tests := []Pathway{
		Pathway{
			[]Graph{
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
			},
			NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
			[]Duplicates{},
			[][]int{},
		},
		Pathway{
			[]Graph{
				NewGraphOnlyFromFile("testdata/graphs/square.txt"),
				NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
			},
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]Duplicates{},
			[][]int{},
		},
	}

	for i, pathway := range tests {
		newPathway := CopyPathway(&pathway)
		if !PathwayEqual(&pathway, &newPathway) {
			t.Errorf("CopyPathway error in test %v\nInput Pathway %v\nCopied Pathway %v",
				i, pathway, newPathway)
		}
	}
}

func TestAssemblyIndex(t *testing.T) {
	tests := []struct {
		pathway       Pathway
		originalGraph Graph
		assemblyIndex int
	}{
		{
			Pathway{
				[]Graph{
					NewGraphOnlyFromFile("testdata/graphs/square.txt"),   // 4 edges
					NewGraphOnlyFromFile("testdata/graphs/triangle.txt"), // 3 edges
				},
				NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
				[]Duplicates{},
				[][]int{},
			},
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"), // 12 edges
			6, // = (12-1) - (4-1) - (3-1) = 6
		},
	}

	for _, tt := range tests {
		assemblyIndex := AssemblyIndex(&tt.pathway, &tt.originalGraph)
		if assemblyIndex != tt.assemblyIndex {
			t.Errorf("Error in Assembly Index, Pathway: %v\nOriginal Graph %v\nExpected %v, Got %v", tt.pathway, tt.originalGraph, tt.assemblyIndex, assemblyIndex)
		}
	}
}

func TestMaxStepsSaved(t *testing.T) {
	square := NewGraphOnlyFromFile("testdata/graphs/square.txt")
	twoSquares, _ := RecombineGraphs(&square, &square)
	nineGrid := NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt") // 12 edges
	doubleNine, _ := RecombineGraphs(&nineGrid, &nineGrid)            // 2 x 12 edges

	tests := []struct {
		pathway    Pathway
		stepsSaved int
	}{
		// Only the remnant is used in the function
		{
			Pathway{
				[]Graph{},
				square,
				[]Duplicates{},
				[][]int{},
			},
			1,
		},
		{
			Pathway{
				[]Graph{},
				twoSquares,
				[]Duplicates{},
				[][]int{},
			},
			2,
		},
		{
			Pathway{
				[]Graph{},
				doubleNine,
				[]Duplicates{},
				[][]int{},
			},
			16,
		},
	}

	for _, tt := range tests {
		stepSaved := MaxStepsSaved(&tt.pathway)
		if stepSaved != tt.stepsSaved {
			t.Errorf("Error in MaxStepsSaved, Pathway: %v, Expected %v, Got %v", tt.pathway, tt.stepsSaved, stepSaved)
		}
	}
}

func TestUpdateAtomEquivalents(t *testing.T) {
	testPath1 := NewPathway([]Graph{}, NewGraph([]int{}, [][2]int{}), []Duplicates{}, [][]int{{1, 2}, {4, 5}, {7}})

	tests := []struct {
		pathway        Pathway
		vertexMap      map[int]int
		newEquivalents [][]int
	}{
		{
			CopyPathway(&testPath1),
			map[int]int{
				1: 3,
			},
			[][]int{{1, 2, 3}, {4, 5}, {7}},
		},
		{
			CopyPathway(&testPath1),
			map[int]int{
				1: 3,
				7: 8,
			},
			[][]int{{1, 2, 3}, {4, 5}, {7, 8}},
		},
		{
			CopyPathway(&testPath1),
			map[int]int{
				1: 3,
				9: 10,
			},
			[][]int{{1, 2, 3}, {4, 5}, {7}, {9, 10}},
		},
	}

	for _, tt := range tests {
		UpdateAtomEquivalents(&tt.pathway, tt.vertexMap)
		if !reflect.DeepEqual(tt.newEquivalents, tt.pathway.atomEquivalents) {
			t.Errorf("UpdateAtomEquivalents error\npathway %v\nvertex map %v\nexpected %v\ngot %v",
				testPath1, tt.vertexMap, tt.newEquivalents, tt.pathway.atomEquivalents)
		}
	}
}


---
assembly_go/pkg/assembly/assemblyparallel.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
	"errors"
	"fmt"
	"math"
	"os"
	"os/signal"
	"sort"
	"sync"
	"time"
)

// This file contains functions specific to the main parallel implementation of the assembly algorithm, the main one being Assembly

// Worker takes pathways from the jobs queue and extends them, placing the results back in the jobs queue
func Worker(jobs chan Pathway, graph *Graph, bestPathways *[]Pathway, activeWorkers *WorkerCounter, variant string, done chan bool) {

	// Initially wait for a job (a Pathway)
	currentPathway := <-jobs

	for {

		// Extend the pathway, putting any results back in the jobs queue for other workers to pick up
		ExtendPathway(&currentPathway, bestPathways, graph, variant, jobs, activeWorkers)

		// TODO: rename, since activeWorkers is now really active jobs
		if activeWorkers.NumWorkers() == 0{
			done <- true
		}
		currentPathway = <-jobs

	}
}

// WorkerCounter is a struct to track the number of active workers. Zero active workers and an empty queue means the process is complete
// WorkerCounter.activeWorkers is initialised as -1, then set to 1 by the first call of Increment, to avoid the process terminating
// on startup
// TODO: Rename, as this now counts active jobs rather than workers
type WorkerCounter struct {
	activeWorkers int64
	mu            sync.Mutex
}
func (workerCounter *WorkerCounter) Increment() {
	workerCounter.mu.Lock()
	if workerCounter.activeWorkers == -1 {
		workerCounter.activeWorkers = 1
	} else {
		workerCounter.activeWorkers++
	}

	workerCounter.mu.Unlock()
}
func (workerCounter *WorkerCounter) Decrement() {
	workerCounter.mu.Lock()
	workerCounter.activeWorkers--
	workerCounter.mu.Unlock()
}

func (workerCounter *WorkerCounter) NumWorkers() int64 {
	var numWorkers int64
	workerCounter.mu.Lock()
	numWorkers = workerCounter.activeWorkers
	workerCounter.mu.Unlock()
	return numWorkers
}

// AssemblyFromMultiMolString take a set of graphs and use as starting pathway. TODO: include duplicates also
// the original graph is the first one, then a pathway with the final residue at the end
func AssemblyFromMultiMolString(mols string, numWorkers int, chanBufferSize int, variant string) []Pathway {
	graphs := ParseMultiMolString(mols, true)

	originalGraph := graphs[0]
	startingPathway := Pathway{
		graphs[1:len(graphs)-1],
		graphs[len(graphs)-1],
		[]Duplicates{},
		[][]int{},
	}

	outputPathway := AssemblyPathway(originalGraph, startingPathway, numWorkers, chanBufferSize, variant)
	return outputPathway
}

// AssemblyToString takes an input molecule in the form of a mol block and returns the
// assembly index and pathway as a string. This is for use in calling from assembly calculator API
// rather than from the executable
func AssemblyToString(molBlock string, numWorkers int, chanBufferSize int, variant string) string {

	graph := MolBlockColourGraph(molBlock)
	start := time.Now()
	pathways := Assembly(graph, numWorkers, chanBufferSize, variant)
	elapsed := time.Now().Sub(start)

	assemblyIndex := AssemblyIndex(&pathways[0], &graph)

	outString := AssemblyString(pathways, &graph)
	outString += fmt.Sprintf("Assembly Index: %v\n", assemblyIndex)
	outString += fmt.Sprintf("Time (seconds):  %v\n", elapsed.Seconds())

	return outString
}

// AssemblySDFBlock is similar to AssemblyToString, but takes an sdf block as input rather than a
// single mol block. The SDF block is interpreted as the first mol being the original molecule,
// the last being the remnant, and the intermediates being the duplicates. The main assembly algorithm
// works on the remnant, and then extends the duplicates. There's no check that the input pathway is sensible,
// e.g. there is no check that the remnant or duplicates exist within the target molecule.
func AssemblySDFBlock(sdfBlock string, numWorkers int, chanBufferSize int, variant string) string {
	graphs := ParseMultiMolString(sdfBlock, true)
	originalGraph, starterPathway := MolListToPathway(graphs, []Duplicates{})

	start := time.Now()
	pathways := AssemblyPathway(originalGraph, starterPathway, numWorkers, chanBufferSize, variant)
	elapsed := time.Now().Sub(start)

	assemblyIndex := AssemblyIndex(&pathways[0], &originalGraph)

	outString := AssemblyString(pathways, &originalGraph)
	outString += fmt.Sprintf("Assembly Index: %v\n", assemblyIndex)
	outString += fmt.Sprintf("Time (seconds):  %v\n", elapsed.Seconds())

	return outString
}


// Assembly takes an input graph and returns assembly pathways, either a shortest pathway
// or all shortest pathways depending on the variant (shortest, all_shortest). More variants may
// be added. all_shortest may have some duplication at the moment, currently only shortest is supported. TODO: test all_shortest
// The process spawns a number of worker goroutines, that take pathways from the jobs queue
// and extend them by a step in all possible ways through finding duplicates. The resultant
// extended pathways are placed back into the jobs queue to be extended further. The jobs queue (a channel)
// is buffered. If full, the goroutine will process the job in a depth first manner, until there is space in the queue.
// numWorkers is the number of worker threads, and chanBufferSize is the buffer size of the queue.
func Assembly(graph Graph, numWorkers int, chanBufferSize int, variant string) []Pathway{

	initPathway := NewStartingPathway(graph)
	return AssemblyPathway(graph, initPathway, numWorkers, chanBufferSize, variant)
}

// AssemblyPathway is called by Assembly to generate pathways based on an initial graph. This can also be used as an entry
// point if starting with a pathway, e.g. to specify a duplicate that must be used.
func AssemblyPathway(graph Graph, initPathway Pathway, numWorkers int, chanBufferSize int, variant string) []Pathway {

	// will return shortest pathway, or all shortest pathways depending on the variant
	// could be extended to all pathways
	ValidateVariants(variant)

	bestPathways := []Pathway{initPathway}
	jobs := make(chan Pathway, chanBufferSize)
	done := make(chan bool, 1)

	jobs <- initPathway

	// Listener for keyboard interrupt. Sends done signal on interrupt, exiting and outputing best pathway found.
	cInt := make(chan os.Signal, 1)
	signal.Notify(cInt, os.Interrupt)
	go func(){
		for sig := range cInt {
			fmt.Printf("Captured %v - exiting with best found pathway\n", sig)
			done <- true
		}
	}()


	activeWorkers := WorkerCounter{
		1,
		sync.Mutex{},
	}

	// var workerMu sync.Mutex

	for i := 0; i < numWorkers; i++ {
		go Worker(jobs, &graph, &bestPathways, &activeWorkers, variant, done)
	}


	<-done // block until something sent to done

	return bestPathways
}


// ExtendPathway takes an input pathway and checks if it can be extended by matching duplicate subgraphs
// New pathways are placed in the jobs queue if it is not full. If the jobs queue is full, the thread proceeds to extend pathways
// In a depth-first fashion. The matching process cycles through subgraphs within the remnant graph based on the path trace algorithm
// described in "Automatic Enumeration of All Connected Subgraphs, Rucker &  Rucker, 2000". For each of those subgraphs, CheckSubgraphMatches
// is called which uses a similar subgraph search on the remaining part of the remnant, checking for matches. There is some
// pruning within the process also.
func ExtendPathway(currentPathway *Pathway, bestPathways *[]Pathway, originalGraph *Graph, variant string, jobs chan Pathway, activeWorkers *WorkerCounter) {

	// If this pathway cannot in principle be extended to a better pathway than the best found so far, then return
	// TODO: If implementing output of all pathways, this will need to be disabled
	if AssemblyIndex(&(*bestPathways)[0], originalGraph) < BestAssemblyIndex(originalGraph, currentPathway) {

		// activeWorkers is set to 1 at the start of the program for the first job, then is incremented when
		// new jobs are added to the jobs pool.
		activeWorkers.Decrement()

		return
	}

	// We only need to consider subgraphs up to half the size of the main graph when checking for duplicates
	sizesToCheck := int(math.Floor(float64(len(currentPathway.remnant.Edges)) / 2))

	// Update the best pathway list if this pathway is better than the ones found so far
	BestPathwayListUpdate(bestPathways, currentPathway, variant)

	// Initialisation for the path tracing algorithm to find all subgraphs
	edgeAdjacencies := currentPathway.remnant.EdgeAdjacencies()
	forbidden := make(map[int]bool)    // map for whether a vertex is forbidden
	forbiddenSize := make(map[int]int) // map of the size of the list a vertex was forbidden from
	var sub []int

	// for each edge
	for i := 0; i < len(currentPathway.remnant.Edges); i++ {
		sub = []int{i} // subgraph starts with just the current edge
		for {

			neighbour, found := nonForbiddenNeighbour(sub, edgeAdjacencies, forbidden)

			// grow the subgraph if a valid neighbour is found
			if found && (len(sub) <= sizesToCheck) {
				sub = append(sub, neighbour)

				// break out this subgraph from the main graph
				subgraph, remnant := BreakGraphOnEdges(&currentPathway.remnant, sub)

				// the subgraph and remnant are sent into CheckSubgraphMatches, which will look for the subgraph being contained within the rest
				// of the remnant. The matches that are found are used to construct new pathways that are placed into the jobs queue.
				// CheckSubgraphMatches returns true if any matches are found (there might be multiple matches)
				match := true
				if len(sub) > 1 {
					match = CheckSubgraphMatches(currentPathway, bestPathways, originalGraph, &subgraph, &remnant, variant, jobs, activeWorkers)
				}

				// if we have found matches of the current subgraph, or if the subgraph is of size 1, then we continue and keep trying to grow the
				// subgraph. If no matches, there will be no matches to larger subgraphs and we can continue to the backtracking steps
				if match{
					continue
				}
			}

			// backtracking steps
			thisForbidSize := len(sub)
			thisForbid := sub[len(sub)-1]                                      // item to forbid
			sub = sub[:len(sub)-1]                                             // pop the forbidden element out
			forbidUpdate(thisForbid, thisForbidSize, forbidden, forbiddenSize) // update forbidden lists

			// backtracking from the first edge means we are done with this edge
			if len(sub) == 0 {
				break
			}

		}
	}

	// activeWorkers is set to 1 at the start of the program for the first job, then is incremented when
	// new jobs are added to the jobs pool.
	activeWorkers.Decrement()

}

// CheckSubgraphMatches takes the takes a remnant graph from a pathway, and a subgraph of that graph, and looks for matches within the remaining part of the remnant.
// It does this by searching through subgraphs of the remnant in a similar way to how the input subgraph was found in ExtendPathway
func CheckSubgraphMatches(currentPathway *Pathway, bestPathways *[]Pathway, originalGraph *Graph, subgraph *Graph, remnant *Graph,
	variant string, jobs chan Pathway, activeWorkers *WorkerCounter) bool {

	// We are only looking for subgraphs of size k to match
	k := len(subgraph.Edges)

	// Initialisation for the path tracing algorithm to find all subgraphs
	edgeAdjacencies := remnant.EdgeAdjacencies() // map of which edges are adjacent, maps edge index to slice of edge indices
	forbidden := make(map[int]bool)              // map for whether a vertex is forbidden
	forbiddenSize := make(map[int]int)           // map of the size of the list a vertex was forbidden from
	var sub []int                                // the current subgraph under construction
	match := false


	for i := 0; i < len(remnant.Edges); i++ {

		sub = []int{i}

		for {

			neighbour, found := nonForbiddenNeighbour(sub, edgeAdjacencies, forbidden)

			// not building subgraphs bigger than k, which is the size of the subgraph we are matching
			if found && (len(sub) <= k) {

				// if a neighbour is available add it to sub
				sub = append(sub, neighbour)

				// check all subgraphs of length k for a match
				if len(sub) == k {

					possibleDuplicate, newRemnant := BreakGraphOnEdges(remnant, sub)

					// Check if the subgraph and possible duplicate are isomorphic. First SubgraphEdgeCompare checks that the
					// sorted edge list of the subgraph is less than that of possibleDuplicate. This is to prevent duplication as otherwise
					// all matchine pairs of subgraphs would be investigated twice
					if SubgraphEdgeCompare(subgraph.Edges, possibleDuplicate.Edges) && GraphsIsomorphic(subgraph, &possibleDuplicate) {
						match = true


						newPathway := CopyPathway(currentPathway)
						newPathway.pathway = append(newPathway.pathway, CopyGraph(subgraph))

						// create bond lists from duplicates
						dupLeft := CopyEdgeList(subgraph.Edges)
						dupRight := CopyEdgeList(possibleDuplicate.Edges)
						newDuplicate := Duplicates{dupLeft, dupRight}
						newPathway.duplicates = append(newPathway.duplicates, newDuplicate)

						// the remnant to use in the new pathway is the a graph comprised of newRemnant and possibleDuplicte
						// but no longer connected. TODO: refactor variable names - I have inadvertenly made them quite confusing
						// As an example, if the graph was A-B-C-D (with A, B, C, D being subgraphs), then we found A was the same as B
						// The new pathway would have duplicate A and Remnant B C-D (i.e. with B not connected to C-D)
						newGraph, vertexMap := RecombineGraphs(&newRemnant, &possibleDuplicate)
						newPathway.remnant = CopyGraph(&newGraph)
						UpdateAtomEquivalents(&newPathway, vertexMap)

						// The newPathway will be added to the jobs queue, if there is space in the queue
						// If there is not, then this goroutine will also extend the pathway, i.e. proceed in a depth first way
						// This is done as workers are likely to write to the jobs channel more than they
						// read from it, and they may all be blocked if the channel is buffered
						// TODO: rename as activeWorkers is now more like active jobs
						select {
						case jobs <- newPathway:
							activeWorkers.Increment()
						default:
							activeWorkers.Increment()
							ExtendPathway(&newPathway, bestPathways, originalGraph, variant, jobs, activeWorkers)

						}

					}


				}
				continue
			}

			// backtracking steps
			thisForbidSize := len(sub)
			thisForbid := sub[len(sub)-1]                                      // item to forbid
			sub = sub[:len(sub)-1]                                             // pop the forbidden element out
			forbidUpdate(thisForbid, thisForbidSize, forbidden, forbiddenSize) // update forbidden lists

			// backtracking from the first edge means we are done with this edge
			if len(sub) == 0 {
				break
			}

		}

	}

	return match
}

// BestPathwayListUpdate replaces the pathways in bestPathways if newPathway is shorter
// and appends to bestPathway is newPathway is equal in length to bestPathway and we are using
// all_shortest variant (note: all_shortest not yet fully implemented/tested)
func BestPathwayListUpdate(bestPathways *[]Pathway, newPathway *Pathway, variant string) {
	var mutex = &sync.Mutex{}
	mutex.Lock()
	bestStepsSaved := PathwayStepsSaved(&(*bestPathways)[0], true)
	newStepsSaved := PathwayStepsSaved(newPathway, true)

	// if more steps are saved, replace the contents of bestStepsSaved
	// if all the shortest paths are requred and the same number of steps is saved, then append the new pathway to the best pathway list
	// TODO: can incorporate check to see if saved pathway already exists using canonicalisation check on duplicates and remnant
	if newStepsSaved > bestStepsSaved {
		*bestPathways = []Pathway{*newPathway}
	} else if newStepsSaved == bestStepsSaved && variant == "all_shortest" {
		*bestPathways = append(*bestPathways, *newPathway)
	}

	mutex.Unlock()
}

// ValidateVariants checks that the variant (e.g. shortest, all_shortest) is valid
func ValidateVariants(variant string) {
	allowedVariants := []string{"shortest", "all_shortest", "all"}
	if helpers.ContainsStr(allowedVariants, variant) {
		return
	}
	errString := "Invalid variant: " + variant
	check(errors.New(errString))
}


// SubgraphEdgeCompare compares two subgraphs to see if the sorted edge list of one is less than the sorted edge list of the other
func SubgraphEdgeCompare(left [][2]int, right [][2]int) bool {

	sortedLeft := Flatten(EdgeSort(left))
	sortedRight := Flatten(EdgeSort(right))

	return helpers.SliceCompare(sortedLeft, sortedRight)
}

// EdgeSort sorts edges by their vertices, and then sorts the whole edge list by the first element. It returns a slice of slice, rather than a
// slice of [2]int, since it's simpler and all that is needed for this purpose
func EdgeSort(edges [][2]int) [][]int {

	// TODO: complete testing

	var newEdgeList [][]int
	for _, e := range edges{
		newEdgeList = append(newEdgeList, []int{e[0], e[1]} )
	}


	for _, e := range newEdgeList{
		sort.Ints(e)
	}


	sort.Slice(newEdgeList, func(i, j int) bool {
		// edge cases
		if len(newEdgeList[i]) == 0 && len(newEdgeList[j]) == 0 {
			return false // two empty slices - so one is not less than other i.e. false
		}
		if len(newEdgeList[i]) == 0 || len(newEdgeList[j]) == 0 {
			return len(newEdgeList[i]) == 0 // empty slice listed "first" (change to != 0 to put them last)
		}

		// both slices len() > 0, so can test this now:
		return newEdgeList[i][0] < newEdgeList[j][0]
	})


	return newEdgeList
}

// Flatten flattens a [][]int into a []int, e.g. {{1, 2}, {3, 4}} -> {1, 2, 3, 4}
func Flatten(s [][]int) []int {
	var outputSlice []int
	for _, outer := range s{
		for _, element := range outer{
			outputSlice = append(outputSlice, element)
		}
	}
	return outputSlice
}

---
assembly_go/pkg/assembly/assemblyparallel_test.go
---
package assembly

import (
	"fmt"
	"io/ioutil"
	"testing"
	"time"
)

func TestAssembly(t *testing.T) {

	// This testing covers ExtendPathway and CheckSubgraphMatches due to the recursive nature of the whole thing



	tests := []struct{
		graph Graph
		assemblyIndex int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			2,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
			2,
		},
		{
			MolColourGraph("testdata/aspirin.mol"),
			8,
		},

	}

	workers := 100
	buf := 100
	for _, tt := range tests{
		testPathway := Assembly(tt.graph, workers, buf, "shortest")[0]
		pathwayString := PathwayString(&testPathway)
		assemblyIndex := AssemblyIndex(&testPathway, &tt.graph)
		if assemblyIndex != tt.assemblyIndex{
			t.Errorf("Assembly error in graph %v\nWorkers, Buffer %v %v\nExpected %v got %v\n%v",
				tt.graph, workers, buf, tt.assemblyIndex, assemblyIndex, pathwayString)
		}
	}

}


func AssemblyTimeTest(graph *Graph, workers int, bufSize int, variant string) (int, time.Duration){

	start := time.Now()
	pathways := Assembly(*graph, 1000, 100000, variant)
	elapsed := time.Now().Sub(start)

	index := AssemblyIndex(&pathways[0], graph)

	return index, elapsed


}

func TestAssemblyToString(t *testing.T) {
	molBytes, _ := ioutil.ReadFile("testdata/aspirin.mol")
	molBlock := string(molBytes)

	resultString := AssemblyToString(molBlock, 100, 100, "shortest")
	fmt.Println(resultString)
}
func TestAssemblyFromMultiMolString(t *testing.T) {
	fileName := "testdata/dual_ring_test.sdf"
	molBytes, _ := ioutil.ReadFile(fileName)
	molString := string(molBytes)
	fmt.Println("MOL STRING: ", molString)

	// strings.Split not working propery here...

	graphs := ParseMultiMolString(molString, true)

	fmt.Println(graphs)


	originalGraph := graphs[0]

	pathways := AssemblyFromMultiMolString(molString, 100, 500, "shortest")

	fmt.Println(AssemblyString(pathways, &originalGraph))
}

func TestAssemblySDFBlock(t *testing.T) {
	fileName := "testdata/dual_ring_test.sdf"
	molBytes, _ := ioutil.ReadFile(fileName)
	molString := string(molBytes)
	//fmt.Println("MOL STRING: ", molString)

	fmt.Println(AssemblySDFBlock(molString, 100, 500, "shortest"))
}

func TestDGImprovements(t *testing.T){
	fmt.Println("test test")

	aspirin := MolColourGraph("testdata/aspirin.mol")
	_= aspirin

	pathways := Assembly(aspirin, 100, 500, "shortest")
	index := AssemblyIndex(&pathways[0], &aspirin)
	fmt.Println("Index: ", index)
	fmt.Println(AssemblyString(pathways, &aspirin))
}


func TestRaceCondition(t *testing.T){
	fmt.Println("Test Race Condition")

	mol := MolColourGraph("testdata/inconsistency.mol")

	counts := make(map[int]int)
	times := 1000
	for i:=0; i < times ; i++{
		pathways := Assembly(mol, 1, 500, "shortest")
		index := AssemblyIndex(&pathways[0], &mol)
		// fmt.Println("Index: ", index)

		if _, ok := counts[index]; ok{
			counts[index] += 1
		} else {
			counts[index] =1
		}

	}
	fmt.Println(counts)
	//fmt.Println(AssemblyString(pathways, &mol))

}

func TestEdgeSort(t *testing.T) {
	testSlice := [][2]int{{3, 4}, {2, 1}, {6, 5}}
	EdgeSort(testSlice)
}

func TestFlatten(t *testing.T) {
	testSlice := [][]int{{3, 4}, {2, 1}, {6, 5}}
	flatSlice := Flatten(testSlice)
	fmt.Println(flatSlice)
}

func TestSubgraphEdgeCompare(t *testing.T) {
	testL := [][2]int{{1, 2}, {3, 4}, {5, 7}}
	testR := [][2]int{{6, 5}, {3, 4}, {2, 1}}
	fmt.Println(SubgraphEdgeCompare(testL, testR))

}

---
assembly_go/pkg/assembly/assemblyserial.go
---
package assembly

import (
	"fmt"
	"math"
)

// this is a version of the assembly algorithm that runs without any concurrency
// These functions are mainly for testing, and are not implemented in the main functions of the program
// You can probably ignore them, unless you have some specific reason to be interested in them

func GraphAssemblySerial(g Graph) Pathway {


	var bestPathway Pathway
	//initPathway := Pathway{
	//	[]Graph{},
	//	g,
	//	[][]int{},
	//}
	initPathway := NewStartingPathway(g)

	//GraphAssemblySerialInner(&initPathway, &bestPathway, &g)
	GraphAssemblySerialInnerDG(&initPathway, &bestPathway, &g, 0)
	fmt.Println("Complete, assembly index: ", AssemblyIndex(&bestPathway, &g))

	return bestPathway
}

// GraphAssemblySerialInnerDG Attemps to implement Daniel's improvement into the algorithm
func GraphAssemblySerialInnerDG(currentPathway *Pathway, bestPathway *Pathway, originalGraph *Graph, level int) {

	if AssemblyIndex(bestPathway, originalGraph) < BestAssemblyIndex(originalGraph, currentPathway) {
		return
	}

	remnantEdges := len(currentPathway.remnant.Edges)
	sizesToCheck := int(math.Floor(float64(remnantEdges) / 2))
	// fmt.Println("RemnantEdges: ", remnantEdges)
	// fmt.Println("Sized to Check: ", sizesToCheck)
	BestPathwayUpdate(bestPathway, currentPathway)

	edgeAdjacencies := currentPathway.remnant.EdgeAdjacencies()
	forbidden := make(map[int]bool)              // map for whether a vertex is forbidden
	forbiddenSize := make(map[int]int)           // map of the size of the list a vertex was forbidden from
	var sub []int

	for i := 0; i < len(currentPathway.remnant.Edges); i++{
		sub = []int{i}  // subgraph starts with just the current edge
		for{

			neighbour, found := nonForbiddenNeighbour(sub, edgeAdjacencies, forbidden)

			if found && (len(sub) <= sizesToCheck){
				sub = append(sub, neighbour)
				// if level == 0 {fmt.Println("sub: ", sub)}
				subgraph, remnant := BreakGraphOnEdges(&currentPathway.remnant, sub)
				match := AllSubgraphsMatch(currentPathway, bestPathway, originalGraph, &subgraph, &remnant, level)
				if match{
					// if level == 0 {fmt.Println("MATCH")}
					continue

				}
				continue // cancel DG bit...
			}

			// backtrack
			thisForbidSize := len(sub)
			thisForbid := sub[len(sub)-1]                                      // item to forbid
			sub = sub[:len(sub)-1]                                             // pop the forbidden element out
			forbidUpdate(thisForbid, thisForbidSize, forbidden, forbiddenSize) // update forbidden lists


			if len(sub) == 0{
				break
			}
		}
	}

}

func AllSubgraphsMatch(currentPathway *Pathway, bestPathway *Pathway, originalGraph *Graph, subgraph *Graph, remnant *Graph, level int) bool {

	k := len(subgraph.Edges) // size of the subgraphs to search for

	//var edgeSubgraphs [][]int
	edgeAdjacencies := remnant.EdgeAdjacencies() // map of which edges are adjacent, maps edge index to slice of edge indices
	forbidden := make(map[int]bool)              // map for whether a vertex is forbidden
	forbiddenSize := make(map[int]int)           // map of the size of the list a vertex was forbidden from
	var sub []int                                // the current subgraph under construction
	match := false


	for i := 0; i < len(remnant.Edges); i++ {

		sub = []int{i}

		for {

			neighbour, found := nonForbiddenNeighbour(sub, edgeAdjacencies, forbidden)
			if found && (len(sub) <= k) {
				// if a neighbour is available add it to sub
				sub = append(sub, neighbour)


				if len(sub) == k {
					//edgeSubgraphs = helpers.CopyAppend(edgeSubgraphs, sub)
					possibleDuplicate, newRemnant := BreakGraphOnEdges(remnant, sub)
					if GraphsIsomorphic(subgraph, &possibleDuplicate) {
						match = true
						//fmt.Println("match: ", sub, match)
						newPathway := CopyPathway(currentPathway)
						newPathway.pathway = append(newPathway.pathway, CopyGraph(&possibleDuplicate))

						dupLeft := CopyEdgeList(subgraph.Edges)
						dupRight := CopyEdgeList(possibleDuplicate.Edges)
						newDuplicate := Duplicates{dupLeft, dupRight}
						newPathway.duplicates = append(newPathway.duplicates, newDuplicate)


						newPathway.duplicates = append(newPathway.duplicates, newDuplicate)
						newGraph, vertexMap := RecombineGraphs(&newRemnant, &possibleDuplicate)
						newPathway.remnant = CopyGraph(&newGraph)
						_ = vertexMap
						GraphAssemblySerialInnerDG(&newPathway, bestPathway, originalGraph, level + 1)

						//extend = true // continue building subgraph only if there is a match

					}
				}
				continue
			}

			// forbid the last item added, remove it, and update forbidden lists
			thisForbidSize := len(sub)
			thisForbid := sub[len(sub)-1]                                      // item to forbid
			sub = sub[:len(sub)-1]                                             // pop the forbidden element out
			forbidUpdate(thisForbid, thisForbidSize, forbidden, forbiddenSize) // update forbidden lists

			// break out of the loop if the subgraph is empty, and move on to the next starting edge
			if len(sub) == 0 {
				break
			}

		}

	}

	return match
}



---
assembly_go/pkg/assembly/assemblyserial_test.go
---
package assembly

import (
	"testing"
)

func TestGraphAssemblySerial(t *testing.T) {
	//aspirin := MolColourGraph("testdata/aspirin.mol")
	//pathway := GraphAssemblySerial(aspirin)
	//PathwayPrint(&pathway)

	//fmt.Println("---737---")
	//mol737 := MolColourGraph("testdata/test_mols/737.mol")
	//pathway737 := GraphAssemblySerial(mol737)
	//PathwayPrint(&pathway737)
	//
	//fmt.Println("---Morphine---")
	//morphine := MolColourGraph("testdata/morphine.mol")
	//morphinePathway := GraphAssemblySerial(morphine)
	//PathwayPrint(&morphinePathway)

	//fmt.Println("---Tryptophan---")
	//tryptophan := MolColourGraph("testdata/tryptophan.mol")
	//tryptophanPathway := GraphAssemblySerial(tryptophan)
	//PathwayPrint(&tryptophanPathway)

	//fmt.Println("---sample test---")
	//sample := MolColourGraph("testdata/test_mols/939561.mol")
	//pathway := GraphAssemblySerial(sample)
	//PathwayPrint(&pathway)
}



---
assembly_go/pkg/assembly/canonical.go
---
package assembly

// This file contains code that implements a version of the nauty graph canonicalisation algorithm within Go (https://pallini.di.uniroma1.it/).
// References:
// Practical Graph Isomorhipsm II, McKay & Piperno
// McKay's Canonical Graph Labeling Algorithm, Hartke & Radcliffe
// TODO: get rid of some of the testing code
// I implemented the algorithm in Go as I think calling the nauty C code might interfere with my goroutines. I don't know this for sure though.
// Might switch to the nauty C code at some point, which is likely much faster.

import (
	"GoAssembly/pkg/helpers"
	"errors"
	"fmt"
	"log"
	"math/rand"
	"reflect"
	"sort"
	"strconv"
	"time"
)

type AutomorphismData struct {
	automorphisms      []*Graph
	automorphismLevels [][]int
}

// Individualise individualises a vertex within a partition, placing it in its own part of the partition in front of the rest of its original partition
// For example, individualise 3 in [[1], [2, 3, 4], [5, 6]] would result in [[1], [3], [2, 4], [5, 6]]
func Individualise(partition [][]int, vertex int) [][]int {
	var individualised [][]int

	for _, part := range partition {
		if helpers.Contains(part, vertex) {

			// add individualised vertex in its own part
			individualised = append(individualised, []int{vertex})

			// add the rest of the vertices in order in a part
			var remainder []int
			for _, v := range part {
				if v != vertex {
					remainder = append(remainder, v)
				}
			}
			if len(remainder) != 0 {
				individualised = append(individualised, remainder)
			}

		} else {
			individualised = append(individualised, part)
		}
	}

	return individualised
}

// Degree returns the degree of a vertex within a graph. It simply calls DegreeInPart, but with the Part being all the vertices in the graph
func Degree(graph *Graph, vertex int) int {
	return DegreeInPart(graph, vertex, graph.Vertices)

}

// DegreeInPart returns the degree of a vertex with respect to a set of other vertices (a part of a partition)
// e.g. if vertex is 4 and part is [1, 2, 3] then this returns the total number of edges between 4 and [1, 2, 3].
// The part can contain the vertex in question.
func DegreeInPart(graph *Graph, vertex int, part []int) int {

	degreeInPart := 0

	for _, edge := range graph.Edges {
		// if one side of the edge is vertex, and the other is in part
		if (vertex == edge[0] && helpers.Contains(part, edge[1])) || (vertex == edge[1] && helpers.Contains(part, edge[0])) {
			degreeInPart++
		}
	}

	return degreeInPart

}

// Shatter returns the shattering of partLeft by partRight, splitting partLeft into parts ordered by degree into partRight
// for example, take the square graph with edges (1,2), (2,3), (3, 4), (4, 1) with partLeft being (1, 2, 3) and partRight being (4).
// then 2 has degree 0 with respect to (4) and both 1 and 3 have degree 1 with respect to 4, so the output is ((2), (1, 3))
func Shatter(graph *Graph, partLeft []int, partRight []int) [][]int {
	var shattering [][]int

	degreeMap := make(map[int][]int)

	for _, v := range partLeft {
		degreeInPart := DegreeInPart(graph, v, partRight)
		helpers.MapUpdate(degreeInPart, v, degreeMap)
	}

	var degrees []int
	for d := range degreeMap {
		degrees = append(degrees, d)
	}
	sort.Ints(degrees)

	for _, d := range degrees {
		shattering = append(shattering, degreeMap[d])
	}

	return shattering
}

// EquitableRefinement returns a more refined partition (where each part of the new partition is a subset of - including possibly being equal to - a part of the original partition)
// The new partition is equitable, meaning that all the vertices within any given part of the partition have the same degree into any other given part. E.g. for the partition
// [[1, 2, 3], [4, 5, 6], [7, 8 ,9]], vertices 1, 2 and 3 will all have the same degree into [1, 2, 3], and the same degree into [4, 5, 6] and [7, 8, 9]. E.g. 1, 2, 3 all have
// degree d1 into [4, 5, 6] and all have degree d2 into [7, 8, 9] but d1 and d2 do not have to be equal.
// If the input partition is already equitable, it is returned unchanged
func EquitableRefinement(graph *Graph, partition [][]int) [][]int {

	refinedPartition := helpers.CopySliceOfSlices(partition)

	for {

		done := true

		for i := 0; i < len(refinedPartition); i++ {
			breakOut := false
			for j := 0; j < len(refinedPartition); j++ {
				shattering := Shatter(graph, refinedPartition[i], refinedPartition[j])

				if len(shattering) > 1 {
					newPartition := helpers.CopySliceOfSlices(refinedPartition[:i])
					newPartition = append(newPartition, shattering...)
					if len(refinedPartition) > i {
						newPartition = append(newPartition, refinedPartition[i+1:]...)
					}
					refinedPartition = helpers.CopySliceOfSlices(newPartition)
					done = false
					breakOut = true
					break
				}

			}
			if breakOut {
				break
			}
		}

		if done {
			break
		}
	}

	return refinedPartition
}

// IsEquitable returns true if a partition is equitable, i.e. every vertex in any given part has the same degree into each other given part
func IsEquitable(graph *Graph, partition [][]int) bool {
	for _, partLeft := range partition {
		for _, partRight := range partition {
			shattering := Shatter(graph, partLeft, partRight)
			if len(shattering) > 1 {
				return false
			}
		}

	}
	return true

}

// CoarsestEquitableColourings returns the set of coarsest equitable colourings of a given partition. If the partition is not equitable, it refines the
// partition using EquitableRefinement. If it is equitable, it chooses the first non-trivial part of the partition (length > 1) and returns the list of equitable
// refinements after individualising each vertex in that part, as well as the individualised vertices
// Colouring and partition mean the same thing, essentially. I should probably make the names consistent at some point.
// TODO: tests
func CoarsestEquitableColourings(graph *Graph, partition [][]int) ([][][]int, []int) {
	var outputColourings [][][]int
	var individualisedVertices []int

	if !IsEquitable(graph, partition) {
		refinement := EquitableRefinement(graph, partition)
		return [][][]int{refinement}, []int{}
	} else {
		for _, part := range partition {
			if len(part) > 1 {
				for _, v := range part {
					individualised := Individualise(partition, v)
					outputColourings = append(outputColourings, EquitableRefinement(graph, individualised))
					individualisedVertices = append(individualisedVertices, v)
				}
				return outputColourings, individualisedVertices
			}
		}
	}

	return nil, nil
}

// SearchTree is the main canonical graph algorithm, which returns a canonical version of the input graph
// An initial colouring can be specified (a partition) if the input graph is already coloured
// TODO: tests
func SearchTree(graph *Graph, initialColouring [][]int, prune bool) Graph {

	canonicalGraphContainer := make([]Graph, 1)
	var bestInvariant [][]int
	var v []int
	treeLevel := []int{0}
	backtrack := []bool{false}
	backtrackLevel := []int{-1}
	automorphisms := AutomorphismData{
		[]*Graph{},
		[][]int{},
	}

	SearchTreeInner(graph, initialColouring, v, canonicalGraphContainer, bestInvariant, &automorphisms, treeLevel, prune, backtrack, backtrackLevel)

	return canonicalGraphContainer[0]
}

// SearchTreeInner is the inner recursive part of the SearchTree algorithm
func SearchTreeInner(graph *Graph, colouring [][]int, v []int, canonicalGraphContainer []Graph, bestInvariant [][]int, automorphisms *AutomorphismData, treeLevel []int, prune bool, backtrack []bool, backtrackLevel []int) {

	if prune && backtrack[0] {
		if len(treeLevel) == backtrackLevel[0] {
			backtrack[0] = false
			backtrackLevel[0] = -1 // prob not necessary
		} else {
			return
		}
	}

	if IsDiscrete(colouring) {

		canonicalCandidate := PermuteGraph(graph, DiscreteColouringToIntSlice(colouring))

		autoFound, level := AutomorphismCheck(&canonicalCandidate, automorphisms)
		_, _ = autoFound, level

		if autoFound {
			// start backtracking to
			// fmt.Println("automorphism found: ", automorphisms.automorphismLevels[level] ," this level ", treeLevel)
			backtrack[0] = true
			backtrackLevel[0] = MaxEqualLevel(automorphisms.automorphismLevels[level], treeLevel)
			return
		} else {
			automorphisms.automorphisms = append(automorphisms.automorphisms, &canonicalCandidate)
			automorphisms.automorphismLevels = append(automorphisms.automorphismLevels, treeLevel)
		}

		if len(canonicalGraphContainer[0].Vertices) == 0 || GraphGreaterThan(&canonicalCandidate, &canonicalGraphContainer[0]) {
			canonicalGraphContainer[0] = canonicalCandidate
		}

	} else {
		equitableColourings, vertices := CoarsestEquitableColourings(graph, colouring)

		for i, newColouring := range equitableColourings {
			newV := make([]int, len(v))
			copy(newV, v)

			if len(vertices) != 0 {
				newV = append(newV, vertices[i])
			}

			newTreeLevel := append(treeLevel, i)

			SearchTreeInner(graph, newColouring, newV, canonicalGraphContainer, bestInvariant, automorphisms, newTreeLevel, prune, backtrack, backtrackLevel)
		}

	}

}

// AutomorphismCheck checks the canonical graph candidate against a list of graphs for automosphisms, and returns whether the graph is found, as well as the
// position in the list
func AutomorphismCheck(canonicalCandidate *Graph, automorphismData *AutomorphismData) (bool, int) {
	for i, g := range automorphismData.automorphisms {
		if GraphEquals(canonicalCandidate, g) {
			return true, i
		}
	}
	return false, -1
}

// IsDiscrete returns true if a colouring is discrete, i.e. every part of the colouring has only 1 vertex
// e.g. [[1],[2],[3],[4],[5]] is discrete, [[1,2],[3],[4],[5]] is not
func IsDiscrete(colouring [][]int) bool {
	for _, part := range colouring {
		if len(part) > 1 {
			return false
		}

	}
	return true
}

// DiscreteColouringToIntSlice takes a discrete colouring, which is a slice of slices each having a single member,
// e.g. {{1}, {2}, {3}, {4}} and flattens it to an int slice, e.g. {1, 2, 3, 4}
func DiscreteColouringToIntSlice(colouring [][]int) []int {
	if !IsDiscrete(colouring) {
		check(errors.New("DiscreteColouringToIntSlice error - colouring is not discrete"))
	}

	var intSlice []int
	for _, part := range colouring {
		if len(part) == 1 {
			intSlice = append(intSlice, part[0])
		} else {
			log.Fatal(errors.New("DiscreteColouringToIntSlice error - colouring is not discrete"))
		}
	}
	return intSlice

}

// PermuteGraph relabels graph nodes based on input permutation. The permutation [4, 1, 3, 2, 5]  on [1, 2, 3, 4, 5]
// should move 1 to where 4 was, 2 to where 1 was etc. The permuted graph is returned.
func PermuteGraph(graph *Graph, permutation []int) Graph {


	if len(permutation) != len(graph.Vertices) {
		log.Fatal(errors.New("PermuteGraph error - permutation must have the same length as the number of vertices in the input graph"))
	}

	// handle coloured graphs - edge colours should be the same
	vertexColoured := len(graph.VertexColours) == len(graph.Vertices)
	edgeColoured := len(graph.EdgeColours) == len(graph.Edges)
	var newVertexColours []string
	var newEdgeColours []string
	var vertexColourMap map[int]string

	if vertexColoured {
		newVertexColours = make([]string, len(graph.Vertices))
		vertexColourMap = VertexColourMap(graph)
	} else {
		newVertexColours = make([]string, 0)
	}


	sortedVertices := make([]int, len(graph.Vertices))
	for i, v := range graph.Vertices {
		sortedVertices[i] = v
	}
	sort.Ints(sortedVertices)

	permutationMap := make(map[int]int)
	for i, vertex := range sortedVertices {
		permutationMap[permutation[i]] = vertex
	}


	newVertices := make([]int, len(graph.Vertices))
	for i, _ := range newVertices {
		newVertices[i] = permutationMap[sortedVertices[i]]
		if vertexColoured {
			newVertexColours[i] = vertexColourMap[sortedVertices[i]]
		}
	}

	var newEdges [][2]int
	for i, e := range graph.Edges {
		newEdges = append(newEdges, [2]int{permutationMap[e[0]], permutationMap[e[1]]})
		if edgeColoured {
			newEdgeColours = append(newEdgeColours, graph.EdgeColours[i])
		}

	}


	return NewColourGraph(newVertices, newEdges, newVertexColours, newEdgeColours)
}

// PermuteColouring returns a permuted colouring (partition). This was just used for testing, not part of the canonical algorithm
func PermuteColouring(graph *Graph, colouring [][]int, permutation []int) [][]int {
	var newColouring [][]int

	sortedVertices := make([]int, len(graph.Vertices))
	for i, v := range graph.Vertices {
		sortedVertices[i] = v
	}
	sort.Ints(sortedVertices)

	permutationMap := make(map[int]int)
	for i, vertex := range sortedVertices {
		permutationMap[permutation[i]] = vertex
	}

	for _, part := range colouring {
		var newPart []int
		for _, v := range part {
			newPart = append(newPart, permutationMap[v])
		}
		newColouring = append(newColouring, newPart)
	}

	return newColouring
}

// FlattenEdgeList converts a list of edges, e.g. {{1, 2}, {3, 4}} to a flattened slice of ints e.g. {1, 2, 3, 4}
// This flat list is used to order the graphs
func FlattenEdgeList(edgeList [][2]int) []int {
	var flatList []int

	for _, e := range edgeList {
		flatList = append(flatList, e[0])
		flatList = append(flatList, e[1])
	}

	return flatList
}

// SliceGreaterThan returns true if the left slice is greater than the right in lexographic order, i.e. the first element that differs between the slices is greater
// or the left slice is longer than the right, where the right is a prefix of the left
func SliceGreaterThan(intSliceLeft []int, intSliceRight []int) bool {

	lenLeft := len(intSliceLeft)
	lenRight := len(intSliceRight)

	i := 0
	for {

		if intSliceLeft[i] != intSliceRight[i] {
			return intSliceLeft[i] > intSliceRight[i]
		}

		// reached end of left fragment with every element equal so far, left cannot be greater
		if i == lenLeft-1 {
			return false
		}

		// reached end of right fragment but not left with every element equal so far, left  is greater
		if i == lenRight-1 {
			return true
		}

		i++
	}

}

// SliceEqual returns true if two slices of ints are equal at each position
func SliceEqual(intSliceLeft []int, intSliceRight []int) bool {

	if len(intSliceLeft) != len(intSliceRight) {
		return false
	}

	for i, _ := range intSliceLeft {
		if intSliceLeft[i] != intSliceRight[i] {
			return false
		}
	}

	return true

}

// GraphGreaterThan returns true if graphLeft is greater than graphRight, as determined by the lexographic ordering of the sorted edge list
func GraphGreaterThan(graphLeft *Graph, graphRight *Graph) bool {
	edgeListLeft := ListPairSort(graphLeft.Edges)
	flatEdgeListLeft := FlattenEdgeList(edgeListLeft)

	edgeListRight := ListPairSort(graphRight.Edges)
	flatEdgeListRight := FlattenEdgeList(edgeListRight)

	return SliceGreaterThan(flatEdgeListLeft, flatEdgeListRight)
}

// GraphColourPartition creates an initial partition for a graph based on colours. If there are no graph colours the initial partition just contains one
// part with all of the vertices. If there are colours, then the initial partition is based on those, in order of colour.
func GraphColourPartition(graph *Graph) [][]int {

	var outputPartition [][]int
	if len(graph.VertexColours) == 0 {
		fullPart := make([]int, len(graph.Vertices))
		copy(fullPart, graph.Vertices)
		outputPartition = append(outputPartition, fullPart)
		return outputPartition
	}

	// make list of all the graph colours
	var colours []string
	for _, c := range graph.VertexColours {
		if !helpers.ContainsStr(colours, c) {
			colours = append(colours, c)
		}
	}
	sort.Strings(colours)  // colours must be in order

	// generate partition based on ordered colours
	outputPartition = make([][]int, len(colours))
	for i, c := range colours {
		for j, v := range graph.Vertices {
			if graph.VertexColours[j] == c {
				outputPartition[i] = append(outputPartition[i], v)
			}
		}
	}

	return outputPartition

}

// MaxEqualLevel returns the final position in a pair of lists where the lists are equal. -1 if not equal at any point.
func MaxEqualLevel(sliceLeft []int, sliceRight []int) int {

	levelMatch := -1

	for i := 0; i < len(sliceLeft); i++ {
		if sliceLeft[i] == sliceRight[i] {
			levelMatch = i
		} else {
			break
		}
	}

	return levelMatch
}

// RandomPermutation randomlu permutes an input slice. For testing.
func RandomPermutation(inputList []int) []int {
	permutedList := make([]int, len(inputList))
	copy(permutedList, inputList)
	rand.Shuffle(len(permutedList), func(i, j int) { permutedList[i], permutedList[j] = permutedList[j], permutedList[i] })
	return permutedList
}

// RandomPermutationList returns a number of random permutations of an input slice. For testing
func RandomPermutationList(inputList []int, numberOfPermutations int) [][]int {

	rand.Seed(time.Now().UnixNano())
	var outputPermutations [][]int
	for i := 0; i < numberOfPermutations; i++ {
		outputPermutations = append(outputPermutations, RandomPermutation(inputList))

	}

	return outputPermutations
}

// CanonicalGraphTest is for some additional canonical testing
func CanonicalGraphTest(graph *Graph, inputColouring [][]int, numberOfPermutations int) bool {
	pass := true

	permutations := RandomPermutationList(graph.Vertices, numberOfPermutations)

	var colouring [][]int
	if len(inputColouring) == 0 {
		colouring = make([][]int, 1)
		vertexList := make([]int, len(graph.Vertices))
		copy(vertexList, graph.Vertices)
		colouring[0] = vertexList
	} else {
		colouring = inputColouring
	}

	var permutedGraphs []Graph
	var permutedColourings [][][]int
	for _, p := range permutations {
		permutedGraphs = append(permutedGraphs, PermuteGraph(graph, p))
		permutedColourings = append(permutedColourings, PermuteColouring(graph, colouring, p))
	}

	var canonicals []Graph
	for i, g := range permutedGraphs {
		canonicalGraph := SearchTree(&g, permutedColourings[i], true)
		canonicals = append(canonicals, canonicalGraph)
	}

	for _, c := range canonicals {
		if !GraphEquals(&c, &canonicals[0]) {
			fmt.Println("not equal", c.Edges, canonicals[0].Edges)
			pass = false
		}
	}


	return pass
}

// RandomGraph builds a random graph for testing by stringing together vertices and then adding some extra edges
// Colours will be assigned to vertices randomly
func RandomGraph(numVertices int, numExtraEdges int, colours []string) Graph {

	var vertices []int
	var edges [][2]int
	var vertexColours []string
	_ = vertexColours

	for i := 1; i <= numVertices; i++ {
		vertices = append(vertices, i)
	}

	vertices = RandomPermutation(vertices)

	// add edges to make a skeleton
	includedVertices := []int{vertices[0]}
	for i := 1; i < len(vertices); i++ {
		vertexToJoin := includedVertices[rand.Intn(len(includedVertices))]
		edges = append(edges, [2]int{vertices[i], vertexToJoin})
		includedVertices = append(includedVertices, vertices[i])

	}


	for i := 0; i < numExtraEdges; i++ {
		randomVertices := RandomPermutation(vertices)
		edges = append(edges, [2]int{randomVertices[0], randomVertices[1]})
	}

	if len(colours) != 0 {
		for i := 0; i < len(vertices); i++ {
			vertexColours = append(vertexColours, colours[rand.Intn(len(colours))])
		}
	}

	return NewColourGraph(vertices, edges, vertexColours, []string{})
}

// RandomGraphCanonicalTest tests canonicalisation across a specified number of random graphs
func RandomGraphCanonicalTest(numGraphs int, numPermutations int, numVerticesRange [2]int, numExtraEdgesRange [2]int, vertexColours []string) bool {

	time.Sleep(1 * time.Second) // in case multiple calls are so fast that the seed is the same
	rand.Seed(time.Now().UnixNano())

	pass := true

	numVertices := rand.Intn(numVerticesRange[1]-numVerticesRange[0]) + numVerticesRange[0]
	numExtraEdges := rand.Intn(numExtraEdgesRange[1]-numExtraEdgesRange[0]) + numExtraEdgesRange[0]

	for i := 0; i < numGraphs; i++ {
		testGraph := RandomGraph(numVertices, numExtraEdges, vertexColours)
		colouring := GraphColourPartition(&testGraph)
		result := CanonicalGraphTest(&testGraph, colouring, numPermutations)
		// fmt.Println(result)
		pass = pass && result
	}

	return pass

}



func GraphsIsomorphic(graphLeft *Graph, graphRight *Graph) bool {


	if !CanonicalInitialCheck(graphLeft, graphRight){

		return false
	}

	var checkGraphLeft Graph
	var checkGraphRight Graph

	// vertex index mapping
	if reflect.DeepEqual(graphLeft.Vertices, graphRight.Vertices){
		checkGraphLeft = *graphLeft
		checkGraphRight = *graphRight
	} else {
		// relabel graphRight to have the same vertex labels as graphLeft
		checkGraphLeft = *graphLeft
		checkGraphRight = GraphVertexRelabel(graphRight, graphLeft.Vertices)
	}


	if len(graphLeft.Edges) == len(graphLeft.EdgeColours){
		checkGraphLeft = EdgeColourConversion(&checkGraphLeft)
		checkGraphRight = EdgeColourConversion(&checkGraphRight)
	}

	canonicalLeft := SearchTree(&checkGraphLeft, GraphColourPartition(&checkGraphLeft), true)
	canonicalRight := SearchTree(&checkGraphRight, GraphColourPartition(&checkGraphRight), true)

	return GraphEquals(&canonicalLeft, &canonicalRight)
}

// GraphVertexRelabel returns a relabeled version of the input graph with the vertices and edges relabeled according to the given labeling
// this is used to ensure the same set of vertex labels is used for the canonicalisation check
func GraphVertexRelabel(graph *Graph, labeling []int) Graph {

	if len(graph.Vertices) != len(labeling){
		log.Fatal("GraphVertexRelabel error - number of vertices does not equal size of labeling")
	}

	// map of the current vertex labels to the new ones
	labelMap := make(map[int]int)
	for i, v := range graph.Vertices{
		labelMap[v] = labeling[i]
	}

	// use label map to generate new edges with the appropriate new vertex labels
	newEdges := make ([][2]int, len(graph.Edges))
	for i, e := range graph.Edges{
		newEdges[i] = [2]int{labelMap[e[0]],labelMap[e[1]]}
	}

	// vertex and edge colours are unchanged
	newVertexColours := make([]string, len(graph.VertexColours))
	newEdgeColours := make([]string, len(graph.EdgeColours))
	copy(newVertexColours, graph.VertexColours)
	copy(newEdgeColours, graph.EdgeColours)

	return NewColourGraph(labeling, newEdges,newVertexColours, newEdgeColours)

}

func CanonicalInitialCheck(graphLeft *Graph, graphRight *Graph) bool{

	// Some basic canonicalisation checks to ensure that the partition of colours is the same
	possibleMatch := len(graphLeft.Vertices) == len(graphRight.Vertices)
	possibleMatch = possibleMatch &&  (len(graphLeft.Edges) == len(graphRight.Edges))
	possibleMatch = possibleMatch &&  (len(graphLeft.VertexColours) == len(graphRight.VertexColours))
	possibleMatch = possibleMatch &&  (len(graphLeft.EdgeColours) == len(graphRight.EdgeColours))

	if !possibleMatch{
		return false
	}

	leftEdgeColours := make([]string, len(graphLeft.EdgeColours))
	copy(leftEdgeColours, graphLeft.EdgeColours)
	sort.Strings(leftEdgeColours)
	rightEdgeColours := make([]string, len(graphRight.EdgeColours))
	copy(rightEdgeColours, graphRight.EdgeColours)
	sort.Strings(rightEdgeColours)
	if !reflect.DeepEqual(leftEdgeColours, rightEdgeColours){
		return false
	}

	leftVertexColours := make([]string, len(graphLeft.VertexColours))
	copy(leftVertexColours, graphLeft.VertexColours)
	sort.Strings(leftVertexColours)
	rightVertexColours := make([]string, len(graphRight.VertexColours))
	copy(rightVertexColours, graphRight.VertexColours)
	sort.Strings(rightVertexColours)
	if !reflect.DeepEqual(leftVertexColours, rightVertexColours){
		return false
	}

	// TODO: test, and add check for map of vertex colours to edge colours

	return true

}

// EdgeColourConversion takes a graph with edge colours and converts it to a layered graph with a different layer for each edge colour. E.g. if there are 3 edge colours
// 1, 2, 3 and vertex colours a, b, c, then each vertex of colour a is split into a linear graph a1-a2-a3, with edges of type 1 going between vertices of type 1, and so on.
// There are more space efficient ways of doing this, e.g. type 1 is layer 1, type 2 is layer 2, type 3 is both layers 1 and 2. Not implemented for now though.
func EdgeColourConversion(graph *Graph) Graph {

	// don't need to do anything if no distinct edge colours
	if len(graph.EdgeColours) < 2 {
		return CopyGraph(graph)
	}

	outGraph := NewColourGraph([]int{}, [][2]int{}, []string{}, []string{})

	vertexMap := make(map[int][]int)
	nextVertex := helpers.MaxIntSlice(graph.Vertices) + 1 // the next vertex index to use

	var edgeColours []string
	for _, c := range graph.EdgeColours {
		if !helpers.ContainsStr(edgeColours, c) {
			edgeColours = append(edgeColours, c)
		}
	}
	sort.Strings(edgeColours)

	numLayers := len(edgeColours)

	// used to map the edge colours to the correct layers
	edgeColourMap := make(map[string]int)
	for i, c := range edgeColours {
		edgeColourMap[c] = i
	}

	// add new vertices to the graph and link the vertices in each layer
	for k, v := range graph.Vertices {
		vertexMap[v] = make([]int, numLayers)
		for i := 0; i < numLayers; i++ {
			if i == 0 {
				outGraph.Vertices = append(outGraph.Vertices, v) // layer 1 is the initial vertices
				vertexMap[v][i] = v
			} else {
				outGraph.Vertices = append(outGraph.Vertices, nextVertex)
				vertexMap[v][i] = nextVertex
				outGraph.Edges = append(outGraph.Edges, [2]int{vertexMap[v][i-1], vertexMap[v][i]}) // link the layers with edges
				nextVertex++
			}
			outGraph.VertexColours = append(outGraph.VertexColours, graph.VertexColours[k]+strconv.Itoa(i)) // the vertices on each layer have a different colour
		}
	}

	// add edges from original graph into the correct layer
	for i, e := range graph.Edges {
		edgeLayerIndex := edgeColourMap[graph.EdgeColours[i]]
		vertLeft := vertexMap[e[0]][edgeLayerIndex]
		vertRight := vertexMap[e[1]][edgeLayerIndex]
		outGraph.Edges = append(outGraph.Edges, [2]int{vertLeft, vertRight})
	}

	return outGraph

}

// EdgeColourRandomGraph returns a random edge coloured graph, for testing
func EdgeColourRandomGraph(numVertices int, numExtraEdges int, vertexColours []string, edgeColours []string) Graph {

	randomGraph := RandomGraph(numVertices, numExtraEdges, vertexColours)

	for i:=0;i<len(randomGraph.Edges);i++ {
		randomGraph.EdgeColours = append(randomGraph.EdgeColours, edgeColours[rand.Intn(len(edgeColours))])
	}

	return randomGraph
}

// EdgeColourRandomCanonicalTest contains some code to test Edge Coloured graph canonicalisation
func EdgeColourRandomCanonicalTest(numPermutations int, numGraphs int, numVerticesRange [2]int, numExtraEdgesRange [2]int, vertexColours []string, edgeColours []string)bool{


	time.Sleep(1 * time.Second) // in case multiple calls are so fast that the seed is the same
	rand.Seed(time.Now().UnixNano())

	pass := true

	numVertices := rand.Intn(numVerticesRange[1]-numVerticesRange[0]) + numVerticesRange[0]
	numExtraEdges := rand.Intn(numExtraEdgesRange[1]-numExtraEdgesRange[0]) + numExtraEdgesRange[0]


	for i := 0; i < numGraphs; i++ {
		canonicals := make([]Graph, 0)
		// canonicals = []Graph{}
		testGraph := EdgeColourRandomGraph(numVertices, numExtraEdges, vertexColours, edgeColours)
		permutations := RandomPermutationList(testGraph.Vertices, numPermutations)

		for _, p := range permutations {
			permutedGraph := PermuteGraph(&testGraph, p)
			edgeGraph := EdgeColourConversion(&permutedGraph)
			edgeGraphColouring := GraphColourPartition(&edgeGraph)


			thisCanonical := SearchTree(&edgeGraph, edgeGraphColouring, true)
			canonicals = append(canonicals, thisCanonical)
		}

		passed := 0
		failed := 0
		for _, c := range canonicals {
			if !GraphEquals(&c, &canonicals[0]) {
				// fmt.Println("not equal", c.Edges, canonicals[0].Edges)
				pass = false
				failed += 1
			} else {
				// fmt.Println("EQUALS")
				passed += 1
			}
		}
		// fmt.Println("Passed: ", passed, ", Failed: ", failed)
	}



	return pass

}

---
assembly_go/pkg/assembly/canonical_test.go
---
package assembly

import (
	"fmt"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

func TestIndividualise(t *testing.T) {

	tests := []struct {
		partition      [][]int
		vertex         int
		individualised [][]int
	}{
		{
			[][]int{{1, 2, 3}, {4, 5}, {6}},
			1,
			[][]int{{1}, {2, 3}, {4, 5}, {6}},
		},
		{
			[][]int{{1}, {2, 3, 4}, {5, 6}},
			3,
			[][]int{{1}, {3}, {2, 4}, {5, 6}},
		},
	}

	for _, tt := range tests {
		individualised := Individualise(tt.partition, tt.vertex)
		if !reflect.DeepEqual(individualised, tt.individualised) {
			t.Errorf("Individualise error, partition %v, vertex %v, expected %v, got %v",
				tt.partition, tt.vertex, tt.individualised, individualised)
		}
	}

}

func TestDegreeInPart(t *testing.T) {

	tests := []struct {
		g      Graph
		vertex int
		part   []int
		degree int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			1,
			[]int{2, 3, 4},
			2,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			1,
			[]int{3},
			0,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			4,
			[]int{1, 2},
			1,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			4,
			[]int{},
			0,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			1,
			[]int{1, 2, 3, 4},
			2,
		},
	}

	for _, tt := range tests {
		degree := DegreeInPart(&tt.g, tt.vertex, tt.part)
		if degree != tt.degree {
			t.Errorf("DegreeInPart error, graph %v, vertex %v, partn %v, expected %v, got %v",
				tt.g, tt.vertex, tt.part, tt.degree, degree)
		}
	}
}

func TestShatter(t *testing.T) {
	tests := []struct {
		graph      Graph
		partLeft   []int
		partRight  []int
		shattering [][]int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{1, 2, 3},
			[]int{4},
			[][]int{{2}, {1, 3}},
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{2, 3, 4},
			[]int{1},
			[][]int{{3}, {2, 4}},
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{1, 2, 3, 4},
			[]int{1, 2, 3, 4},
			[][]int{{1, 2, 3, 4}},
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{1, 2},
			[]int{3, 4},
			[][]int{{1, 2}},
		},
	}

	for _, tt := range tests {
		shattering := Shatter(&tt.graph, tt.partLeft, tt.partRight)
		if !reflect.DeepEqual(shattering, tt.shattering) {
			t.Errorf("Shattering error, graph %v, partLeft %v, partRight %v, expected %v, got %v",
				tt.graph, tt.partLeft, tt.partRight, tt.shattering, shattering)
		}
	}
}

func TestDegree(t *testing.T) {
	tests := []struct {
		graph  Graph
		vertex int
		degree int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			1,
			2,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			2,
			2,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			3,
			2,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			4,
			2,
		},
	}

	for _, tt := range tests {
		degree := Degree(&tt.graph, tt.vertex)
		if degree != tt.degree {
			t.Errorf("Degree error, graph %v, vertex %v, expected %v, got %v",
				tt.graph, tt.vertex, tt.degree, degree)
		}
	}
}

func TestEquitableRefinement(t *testing.T) {
	tests := []struct {
		graph            Graph
		partition        [][]int
		refinedPartition [][]int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[][]int{{1, 2, 3, 4, 5, 6, 7, 8, 9}},
			[][]int{{1, 3, 7, 9}, {2, 4, 6, 8}, {5}},
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[][]int{{1, 3, 7, 9}, {2, 4, 6, 8}, {5}},
			[][]int{{1, 3, 7, 9}, {2, 4, 6, 8}, {5}},
		},
	}

	for _, tt := range tests {
		refinedPartition := EquitableRefinement(&tt.graph, tt.partition)
		if !reflect.DeepEqual(refinedPartition, tt.refinedPartition) {
			t.Errorf("EquitableRefinement error, graph %v, partition %v, expected %v, got %v",
				tt.graph, tt.partition, tt.refinedPartition, refinedPartition)
		}
	}
}

func TestIsEquitable(t *testing.T) {
	tests := []struct {
		graph     Graph
		partition [][]int
		equitable bool
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[][]int{{1, 2, 3, 4, 5, 6, 7, 8, 9}},
			false,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[][]int{{1, 3, 7, 9}, {2, 4, 6, 8}, {5}},
			true,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[][]int{{1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}},
			true,
		},
	}

	for _, tt := range tests {
		equitable := IsEquitable(&tt.graph, tt.partition)
		if equitable != tt.equitable {
			t.Errorf("IsEquitable error, graph %v, partition %v, expected %v, got %v",
				tt.graph, tt.partition, tt.equitable, equitable)
		}
	}
}

func TestCoarsestEquitableColourings(t *testing.T) {
	g := NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt")
	CoarsestEquitableColourings(&g, [][]int{{1, 2, 3, 4, 5, 6, 7, 8, 9}})
	CoarsestEquitableColourings(&g, [][]int{{1, 3, 7, 9}, {2, 4, 6, 8}, {5}})

	//fmt.Println(EquitableRefinement(&g, [][]int{{1}, {3, 7, 9}, {2, 4, 6, 8}, {5}}))

}

func TestIsDiscrete(t *testing.T) {
	tests := []struct {
		colouring [][]int
		discrete  bool
	}{
		{
			[][]int{{1}, {2}, {3}, {4}, {5}},
			true,
		},
		{
			[][]int{{1, 2}, {3}, {4}, {5}},
			false,
		},
		{
			[][]int{{1}, {2}, {3}, {4}, {5, 6}},
			false,
		},
		{
			[][]int{},
			true,
		},
	}

	for _, tt := range tests {
		discrete := IsDiscrete(tt.colouring)
		if discrete != tt.discrete {
			t.Errorf("IsDiscrete error, colouring %v, expected %v, got %v",
				tt.colouring, tt.discrete, discrete)
		}
	}
}

func TestDiscreteColouringToIntSlice(t *testing.T) {
	tests := []struct {
		colouring [][]int
		intSlice  []int
	}{
		{
			[][]int{{1}},
			[]int{1},
		},
		{
			[][]int{{1}, {2}, {3}, {4}},
			[]int{1, 2, 3, 4},
		},
		{
			[][]int{{9}, {7}, {6}, {8}, {5}},
			[]int{9, 7, 6, 8, 5},
		},
	}

	for _, tt := range tests {
		intSlice := DiscreteColouringToIntSlice(tt.colouring)
		if !reflect.DeepEqual(intSlice, tt.intSlice) {
			t.Errorf("DiscreteColouringToIntSlice error, colouring %v, expected %v, got %v",
				tt.colouring, tt.intSlice, intSlice)
		}
	}
}

func TestPermuteGraph(t *testing.T) {

	squareGraph := NewGraphOnlyFromFile("testdata/graphs/square.txt")

	PermuteGraph(&squareGraph, []int{3, 1, 2, 4})

	tests := []struct {
		graph       Graph
		permutation []int
		permuted    Graph
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{2, 1, 3, 4},
			NewColourGraph([]int{2, 1, 3, 4}, [][2]int{{2, 1}, {1, 3}, {3, 4}, {4, 2}}, []string{}, []string{}),
		},

		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{3, 2, 4, 1},
			NewColourGraph([]int{4, 2, 1, 3}, [][2]int{{4, 2}, {2, 1}, {1, 3}, {3, 4}}, []string{}, []string{}),
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			[]int{3, 2, 4, 1},
			NewColourGraph([]int{4, 2, 1, 3}, [][2]int{{4, 2}, {2, 1}, {1, 3}, {3, 4}}, []string{"Red", "Blue", "Red", "Blue"}, []string{"A", "B", "B", "A"}),
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[]int{2, 4, 1, 3, 7, 9, 8, 6, 5},
			NewColourGraph([]int{3, 1, 4, 2, 9, 8, 5, 7, 6}, [][2]int{{3, 1}, {1, 4}, {2, 9}, {9, 8}, {5, 7}, {7, 6}, {3, 2}, {2, 5}, {1, 9}, {9, 7}, {4, 8}, {8, 6}}, []string{}, []string{}),
		},
	}

	for _, tt := range tests {
		permutedGraph := PermuteGraph(&tt.graph, tt.permutation)
		if !GraphEquals(&tt.permuted, &permutedGraph) {
			t.Errorf("PermuteGraph error\ngraph %v\npermutatiopn %v\nexpected %v\ngot %v",
				tt.graph, tt.permutation, tt.permuted, permutedGraph)
		}
	}

}

func TestSliceGreaterThan(t *testing.T) {
	tests := []struct {
		sliceLeft   []int
		sliceRight  []int
		greaterThan bool
	}{
		{
			[]int{1, 2, 3},
			[]int{1, 2, 3},
			false,
		},
		{
			[]int{1, 2, 3},
			[]int{1, 2},
			true,
		},
		{
			[]int{1, 2, 3},
			[]int{1, 2, 3, 4},
			false,
		},
		{
			[]int{2, 3},
			[]int{1, 2, 3, 4},
			true,
		},
		{
			[]int{1, 2, 3, 4, 5},
			[]int{4},
			false,
		},
		{
			[]int{2},
			[]int{1, 2, 3, 4, 5, 6, 7},
			true,
		},
	}

	for _, tt := range tests {
		greaterThan := SliceGreaterThan(tt.sliceLeft, tt.sliceRight)
		if greaterThan != tt.greaterThan {
			t.Errorf("SliceGreaterThan error, sliceLeft %v, sliceRight %v, expected %v, got %v",
				tt.sliceLeft, tt.sliceRight, tt.greaterThan, greaterThan)
		}
	}
}

func TestSliceEqual(t *testing.T) {
	tests := []struct {
		sliceLeft  []int
		sliceRight []int
		equal      bool
	}{
		{
			[]int{},
			[]int{},
			true,
		},
		{
			[]int{1, 2, 3},
			[]int{1, 2, 3},
			true,
		},
		{
			[]int{1, 2, 3},
			[]int{1, 2, 3, 4},
			false,
		},
		{
			[]int{1, 2, 3, 4},
			[]int{1, 2, 3},
			false,
		},
		{
			[]int{4, 5, 6},
			[]int{1, 2, 3},
			false,
		},
	}

	for _, tt := range tests {
		equal := SliceEqual(tt.sliceLeft, tt.sliceRight)
		if equal != tt.equal {
			t.Errorf("SliceEqual error, sliceLeft %v, sliceRight %v, expected %v, got %v",
				tt.sliceLeft, tt.sliceRight, tt.equal, equal)
		}
	}
}

func TestFlattenEdgeList(t *testing.T) {
	tests := []struct {
		edgeList [][2]int
		flatList []int
	}{
		{
			[][2]int{{1, 2}, {3, 4}},
			[]int{1, 2, 3, 4},
		},
		{
			[][2]int{{2, 3}, {3, 4}, {4, 1}},
			[]int{2, 3, 3, 4, 4, 1},
		},
		{
			[][2]int{},
			nil,
		},
	}

	for _, tt := range tests {
		flatList := FlattenEdgeList(tt.edgeList)
		if !reflect.DeepEqual(flatList, tt.flatList) {
			t.Errorf("FlattenEdgeList error, edgeList %v, expected %v, got %v",
				tt.edgeList, tt.flatList, flatList)
		}
	}
}

func TestGraphGreaterThan(t *testing.T) {
	tests := []struct {
		graphLeft   Graph
		graphRight  Graph
		greaterThan bool
	}{
		{
			NewGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {3, 4}}),
			NewGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {1, 4}}),
			true,
		},
		{
			NewGraph([]int{1, 2, 3, 4, 5}, [][2]int{{1, 2}, {2, 3}, {3, 4}, {4, 1}, {1, 5}}),
			NewGraph([]int{1, 2, 3, 4, 5}, [][2]int{{1, 2}, {2, 3}, {3, 4}, {4, 1}, {4, 5}}),
			false,
		},
	}

	for _, tt := range tests {
		greaterThan := GraphGreaterThan(&tt.graphLeft, &tt.graphRight)
		if greaterThan != tt.greaterThan {
			t.Errorf("GraphGreaterThan error, graphLeft %v, graphRight %v, expected %v, got %v",
				tt.graphLeft, tt.graphRight, tt.greaterThan, greaterThan)
		}
	}
}

func TestSearchTree(t *testing.T) {
	nineGrid := NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt")
	initialColouring := [][]int{{1, 2, 3, 4, 5, 6, 7, 8, 9}}
	SearchTree(&nineGrid, initialColouring, true)
}

func TestRandomPermutation(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	inputPerm := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	for i := 0; i < 10; i++ {
		fmt.Println(RandomPermutation(inputPerm))
	}
}

func TestRandomPermutationList(t *testing.T) {
	inputList := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}

	fmt.Println(RandomPermutationList(inputList, 10))

}

func TestCanonicalGraphTest(t *testing.T) {
	nineGrid := NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt")
	pass := CanonicalGraphTest(&nineGrid, [][]int{{1, 3}, {7, 9}, {2, 4, 6}, {8}, {5}}, 100)
	fmt.Println("all canonicals equal", pass)
}

func TestRandomGraph(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	RandomGraph(5, 3, []string{"A", "B"})
}

func TestGraphColourPartition(t *testing.T) {
	tests := []struct {
		graph           Graph
		colourPartition [][]int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			[][]int{{2, 4}, {1, 3}},
		},
		{
			NewColourGraph([]int{1, 2, 3, 4, 5, 6}, [][2]int{{1, 2},{2, 3},{3,4},{4,5},{5,6}}, []string{"A", "B", "B", "C", "B", "A"}, []string{}),
			[][]int{{1, 6}, {2, 3, 5}, {4}},
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/nine_grid.txt"),
			[][]int{{1, 2, 3, 4, 5, 6, 7, 8, 9}},
		},
	}

	for _, tt := range tests{
		colourPartition := GraphColourPartition(&tt.graph)
		if !reflect.DeepEqual(colourPartition, tt.colourPartition){
			t.Errorf("GraphColourPartition error, graph %v, expected %v, got %v",
				tt.graph, tt.colourPartition, colourPartition)
		}
	}
}

func TestRandomGraphCanonicalTest(t *testing.T) {
	result := RandomGraphCanonicalTest(50, 100, [2]int{3, 20}, [2]int{3, 10}, []string{"A", "B", "X", "F", "yy"})
	print("Random Graph Canonical Test Result: ", result)
}



func TestMaxEqualLevel(t *testing.T) {
	tests := []struct{
		sliceLeft []int
		sliceRight []int
		maxEqualLevel int
	}{
		{
			[]int{1, 2, 3, 4, 5},
			[]int{1, 2, 3, 5, 5},
			2,
		},
		{
			[]int{1, 2, 3, 4, 5},
			[]int{1, 2, 3, 4, 5},
			4,
		},
		{
			[]int{0, 1, 2 ,3, 4},
			[]int{0, 9, 9, 9, 9},
			0,
		},
		{
			[]int{0, 1, 2 ,3, 4},
			[]int{9, 9, 9, 9, 9},
			-1,
		},
	}

	for _, tt := range tests{
		maxEqualLevel := MaxEqualLevel(tt.sliceLeft, tt.sliceRight)
		if maxEqualLevel != tt.maxEqualLevel{
			t.Errorf("MaxEqualLevel error, sliceLeft %v, sliceRight %v, expected %v, got %v",
				tt.sliceLeft, tt.sliceRight, tt.maxEqualLevel, maxEqualLevel)
		}
	}
}


func TestEdgeColourConversion(t *testing.T) {
	squareColoured := NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt")

	fmt.Println("Square Coloured:\n", squareColoured)

	edgeGraph := EdgeColourConversion(&squareColoured)
	fmt.Println("Square Coloured Edge Converted:\n", edgeGraph)

}

func TestEdgeColourRandomGraph(t *testing.T) {
	fmt.Println(EdgeColourRandomGraph(6, 3, []string{"A", "B"}, []string{"X", "Y", "Z"}))
}

func TestEdgeColourRandomCanonicalTest(t *testing.T) {
	result := EdgeColourRandomCanonicalTest(20, 20, [2]int{3, 8}, [2]int{1, 3}, []string{"A", "B", "C"}, []string{"X","Y","Z"})
	fmt.Println("Edge Colour Random Test Result: ", result)
	if !result{
		t.Error("TestEdgeColourRandomCanonicalTest fail - creation of random edge coloured graph, conversion to layered graph, permutation and canonicalisation check. Some or all canonical graphs not equal")
	}
}

func TestGraphsIsomorphic(t *testing.T) {
	tests := []struct{
		graphLeft Graph
		graphRight Graph
		isomorphic bool
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			NewGraphOnlyFromFile("testdata/graphs/square_isomorph.txt"),
			true,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			NewGraphOnlyFromFile("testdata/graphs/square_isomorph.txt"),
			false,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			NewGraphOnlyFromFile("testdata/graphs/not_square.txt"),
			false,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			NewGraphOnlyFromFile("testdata/graphs/square_coloured_isomorphic.txt"),
			true,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			NewGraphOnlyFromFile("testdata/graphs/square_coloured_relabeled.txt"),
			true,
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/a_test_1.txt"),
			NewGraphOnlyFromFile("testdata/graphs/a_test_2.txt"),
			true,
		},
	}

	for _, tt := range tests{
		isomorphic := GraphsIsomorphic(&tt.graphLeft, &tt.graphRight)
		if isomorphic != tt.isomorphic{
			t.Errorf("GraphsIsomorphic error, graphLeft %v, graphRight %v, expected %v, got %v",
				tt.graphLeft, tt.graphRight, tt.isomorphic, isomorphic)
		}
	}
}

func TestGraphVertexRelabel(t *testing.T) {
	tests := []struct {
		graph Graph
		labeling []int
		newGraph Graph
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			[]int{0, 1, 2, 3},
			NewGraphOnlyFromFile("testdata/graphs/square_coloured_relabeled.txt"),
		},
	}

	for _, tt := range tests{
		newGraph := GraphVertexRelabel(&tt.graph, tt.labeling)
		if !GraphEquals(&newGraph, &tt.newGraph){
			t.Errorf("GraphVertexRelabel error, graph %v, labeling %v, expected new graph %v, got %v",
				tt.graph, tt.labeling, tt.newGraph, newGraph)
		}
	}
}


---
assembly_go/pkg/assembly/graphsplit.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
	"errors"
)

// Code related to splitting graphs up etc. This could probably be moved to some other file


// BreakGraphOnEdges returns two graph, one comprising the edges specified, and the other the remaining part
func BreakGraphOnEdges(g *Graph, edges []int) (Graph, Graph) {

	breakGraph := NewColourGraph(
		[]int{},
		[][2]int{},
		[]string{},
		[]string{},
	)

	remnantGraph := NewColourGraph(
		[]int{},
		[][2]int{},
		[]string{},
		[]string{},
	)

	// distribute the edges across the two graphs
	for i, _ := range g.Edges {
		if helpers.Contains(edges, i) {
			err := CopyGraphEdge(g, &breakGraph, i)
			check(err)
		} else {
			err := CopyGraphEdge(g, &remnantGraph, i)
			check(err)
		}
	}

	return breakGraph, remnantGraph

}

// CopyGraphEdge copies an edge from one graph to another
func CopyGraphEdge(oldGraph *Graph, newGraph *Graph, edgeIndex int) error {

	// copy the edge to the new graph
	newGraph.Edges = append(newGraph.Edges, oldGraph.Edges[edgeIndex])

	// copy the edge colours to the new graph, if there are any
	if len(oldGraph.EdgeColours) != 0 {
		if len(oldGraph.EdgeColours) != len(oldGraph.Edges) {
			return errors.New("graph has Edge Colours specified, but the number of edge colours does not equal number of edges")
		} else {
			newGraph.EdgeColours = append(newGraph.EdgeColours, oldGraph.EdgeColours[edgeIndex])
		}
	}

	// copy the associated vertices
	err := CopyGraphVerticesFromEdge(oldGraph, newGraph, edgeIndex)
	check(err)

	return nil
}

// CopyGraphVerticesFromEdge copies vertices associated with a particular edge from one graph to another
func CopyGraphVerticesFromEdge(oldGraph *Graph, newGraph *Graph, edgeIndex int) error {

	for _, v := range oldGraph.Edges[edgeIndex] {
		if !helpers.Contains(newGraph.Vertices, v) {

			// add vertex to new graph
			newGraph.Vertices = append(newGraph.Vertices, v)

			// get position of v in old graph
			vPosition := -1
			for i, posV := range oldGraph.Vertices {
				if posV == v {
					vPosition = i
				}
			}
			if vPosition == -1 {
				return errors.New("there is a vertex in the edge set of the input graph that does not appear in the vertex list of the input graph")
			}

			// add vertex colour to new graph if vertex colours were specified
			if len(oldGraph.VertexColours) != 0 {
				if len(oldGraph.VertexColours) != len(oldGraph.Vertices) {
					return errors.New("graph has Vertex Colours specified, but the number of vertex colours does not equal number of vertices")
				} else {
					newGraph.VertexColours = append(newGraph.VertexColours, oldGraph.VertexColours[vPosition])
				}
			}

		}

	}
	return nil
}

// RecombineGraphs takes a pair of input graphs and puts them into a single graph object, relabeling the vertices of graphRight
// No edges are added between the two graphs in the new object
func RecombineGraphs(graphLeft *Graph, graphRight *Graph) (Graph, map[int]int) {
	var outputEdges [][2]int
	var outputVertices []int
	var outputEdgeColours []string
	var outputVertexColours []string

	// copy left edges
	for i, edge := range graphLeft.Edges {
		outputEdges = append(outputEdges, edge)
		if GraphIsEdgeColoured(graphLeft) {
			outputEdgeColours = append(outputEdgeColours, graphLeft.EdgeColours[i])
		}
	}

	// copy left vertices
	for i, vertex := range graphLeft.Vertices {
		outputVertices = append(outputVertices, vertex)
		if GraphIsVertexColoured(graphLeft) {
			outputVertexColours = append(outputVertexColours, graphLeft.VertexColours[i])
		}
	}

	maxVertexLeft := helpers.MaxIntSlice(graphLeft.Vertices)
	maxVertexRight := helpers.MaxIntSlice(graphRight.Vertices)
	nextVertex := helpers.MaxIntSlice([]int{maxVertexLeft, maxVertexRight}) + 1

	// copy right vertices
	vertexMap := make(map[int]int)
	for i, vertex := range graphRight.Vertices {
		newVertex := vertex
		if helpers.Contains(outputVertices, vertex) {
			newVertex = nextVertex
			nextVertex++
		}
		outputVertices = append(outputVertices, newVertex)
		vertexMap[vertex] = newVertex
		if GraphIsVertexColoured(graphRight) {
			outputVertexColours = append(outputVertexColours, graphRight.VertexColours[i])
		}
	}

	// copy right edges
	for i, edge := range graphRight.Edges {
		outputEdges = append(outputEdges, [2]int{vertexMap[edge[0]], vertexMap[edge[1]]})
		if GraphIsEdgeColoured(graphRight) {
			outputEdgeColours = append(outputEdgeColours, graphRight.EdgeColours[i])
		}
	}

	return NewColourGraph(outputVertices, outputEdges, outputVertexColours, outputEdgeColours), vertexMap

}



// ConnectedComponentEdges finds sets of edges corresponding to all connected components in the graph
func ConnectedComponentEdges(g *Graph) [][]int {
	edgeAdj := g.EdgeAdjacencies()

	var edgesUsed []int
	var edgeSets [][]int
	for i := range g.Edges{
		if !helpers.Contains(edgesUsed, i){
			component := ConnectedComponent(i, edgeAdj)
			edgeSets = append(edgeSets, component)
			for _, j := range component{
				edgesUsed = append(edgesUsed, j)
			}
		}
	}
	return edgeSets
}

// ConnectedComponent returns the connected component of a graph that contains a given edge
func ConnectedComponent(edge int, edgeAdj map[int][]int) []int {
	component := []int{edge}
	for i := 0; i < len(component); i++{
		for _, j := range edgeAdj[component[i]]{
			if !helpers.Contains(component, j){
				component = append(component, j)
			}
		}
	}
	return component
}

---
assembly_go/pkg/assembly/graphsplit_test.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
	"reflect"
	"sort"
	"testing"
)

func TestBreakGraphOnEdges(t *testing.T) {
	tests := []struct {
		g               Graph
		edges           []int
		raisesException bool
		breakGraph      Graph
		remnantGraph    Graph
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[]int{0, 1},
			false,
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}}),
			NewGraph([]int{3, 4, 1}, [][2]int{{3, 4}, {4, 1}}),
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
			[]int{0},
			false,
			NewGraph([]int{0, 1}, [][2]int{{0, 1}}),
			NewGraph([]int{0, 1, 2}, [][2]int{{1, 2}, {2, 0}}),
		},
		{
			NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
			[]int{0, 1, 2},
			false,
			NewColourGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 4}}, []string{"Red", "Blue", "Red", "Blue"}, []string{"A", "B", "B"}),
			NewColourGraph([]int{1, 4}, [][2]int{{1, 4}}, []string{"Red", "Blue"}, []string{"A"}),
		},
	}

	for _, tt := range tests {
		breakGraph, remnantGraph := BreakGraphOnEdges(&tt.g, tt.edges)

		eq1 := GraphEquals(&breakGraph, &tt.breakGraph)
		eq2 := GraphEquals(&remnantGraph, &tt.remnantGraph)
		if !(eq1 && eq2) {
			t.Errorf("BreakGraphOnEdges error\ninput graph %v\nbreak on edges %v\nexpected\n%v\n%v\ngot\n%v\n%v",
				tt.g, tt.edges, tt.breakGraph, tt.remnantGraph, breakGraph, remnantGraph)
		}
	}

}


func TestRecombineGraphs(t *testing.T) {
	tests := []struct {
		gLeft   Graph
		gRight  Graph
		gOutput Graph
	}{
		{
			NewColourGraph([]int{1, 2, 4}, [][2]int{{1, 2}, {1, 4}}, []string{"B", "B", "A"}, []string{"Y", "X"}),
			NewColourGraph([]int{2, 4, 3, 5}, [][2]int{{2, 3}, {3, 4}, {3, 5}}, []string{"A", "B", "A", "A"}, []string{"X", "X", "Y"}),
			NewColourGraph([]int{1, 2, 4, 6, 7, 3, 5}, [][2]int{{1, 2}, {1, 4}, {6, 3}, {3, 7}, {3, 5}}, []string{"B", "B", "A", "A", "B", "A", "A"}, []string{"Y", "X", "X", "X", "Y"}),
		},
	}

	for _, tt := range tests {
		gOutput, _ := RecombineGraphs(&tt.gLeft, &tt.gRight)
		if !GraphEquals(&gOutput, &tt.gOutput) {
			t.Errorf("Error in Recombine Graphs\nG1: %v\nG2: %v\nExpected %v\nGot %v", tt.gLeft, tt.gRight, tt.gOutput, gOutput)
		}
	}
}

func TestConnectedComponent(t *testing.T) {
	tests := []struct {
		graph     Graph
		edge      int
		component []int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			0,
			[]int{0, 1, 2, 3},
		},
		{
			NewGraph([]int{0, 1, 2, 3}, [][2]int{{0, 1}, {2, 3}}),
			0,
			[]int{0},
		},
		{
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {2, 3}, {3, 1}, {4, 5}}),
			1,
			[]int{0, 1, 2, 3},
		},
		{
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {2, 3}, {3, 1}, {4, 5}}),
			4,
			[]int{4},
		},
		{
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {2, 3}, {4, 5}, {3, 1}}),
			4,
			[]int{0, 1, 2, 4},
		},
	}

	for _, tt := range tests {
		edgeAdj := tt.graph.EdgeAdjacencies()
		component := ConnectedComponent(tt.edge, edgeAdj)
		sort.Ints(component)
		if !reflect.DeepEqual(component, tt.component) {
			t.Errorf("Error in ConnectedComponent, Graph: %v, edge: %v, Expected %v, Got %v", tt.graph, tt.edge, tt.component, component)
		}
	}
}

func TestConnectedComponentEdges(t *testing.T) {
	tests := []struct {
		graph      Graph
		components [][]int
	}{
		{
			NewGraphOnlyFromFile("testdata/graphs/square.txt"),
			[][]int{{0, 1, 2, 3}},
		},
		{
			NewGraph([]int{0, 1, 2, 3}, [][2]int{{0, 1}, {2, 3}}),
			[][]int{{0}, {1}},
		},
		{
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {2, 3}, {3, 1}, {4, 5}}),
			[][]int{{0, 1, 2, 3}, {4}},
		},
		{
			NewGraph([]int{0, 1, 2, 3, 4, 5}, [][2]int{{0, 1}, {1, 2}, {2, 3}, {4, 5}, {3, 1}}),
			[][]int{{0, 1, 2, 4}, {3}},
		},
	}

	for _, tt := range tests{
		components := ConnectedComponentEdges(&tt.graph)
		helpers.SortSliceOfSlices(components)
		helpers.SortSliceOfSlices(tt.components)
		if !reflect.DeepEqual(components, tt.components){
			t.Errorf("Error in ConnectedComponent, Graph: %v, Expected %v, Got %v", tt.graph, tt.components, components)
		}
	}
}


---
assembly_go/pkg/assembly/graphstruct.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
	"bufio"
	"errors"
	"fmt"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
)

// Code in this file relates mainly to the Graph struct

type Graph struct {
	Vertices      []int
	Edges         [][2]int
	// Adjacencies   map[int][]int
	VertexColours []string
	EdgeColours   []string
}

// NewColourGraph constructs a new Graph based on input vertices,edged, vertex and edge colours
func NewColourGraph(vertices []int, edges [][2]int, vColours []string, eColours []string) Graph {
	g := Graph{
		Vertices:      vertices,
		Edges:         edges,
		VertexColours: vColours,
		EdgeColours:   eColours,
	}

	// g.CalculateAdjacencies()
	return g

}

// NewGraph creates a new graph from vertices and edges. It just calls NewColourGraph, but with
// blank vertex and edge colours
func NewGraph(vertices []int, edges [][2]int) Graph {

	return NewColourGraph(vertices, edges, []string{}, []string{})
}

// NewGraphOnlyFromFile returns a graph from a graph file, but without a graph name or error
func NewGraphOnlyFromFile(filePath string) Graph {
	g, _, _ := NewGraphFromFile(filePath)
	return g
}


// NewGraphFromScanner returns a graph based from a scanner object, either from NewGraphFromFile or
// NewGraphFromString . The graph text should contain 5 lines:
// 1. A brief description of the graph; 2. Vertex indices separated by spaces, e.g. "0 1 2 3"
// 3. A list of edges as vertex indices separated with spaces, e.g. 0 1 1 2 2 3 (must have even length)
// 4. A list of vertex colour as strings (length = length of vertex list), or single "!" if not coloured
// 5. A list of edge colours as strings (length = length of edge list), or single "!" if not coloured
// If the file only has 3 lines, graph is assumed to have no vertex or edge colours
func NewGraphFromScanner(scanner *bufio.Scanner) (Graph, string, error){
	var graphName string
	var vertices []int
	var edges [][2]int
	vertexColours := make([]string, 0)
	edgeColours := make([]string, 0)
	i := 0

	for scanner.Scan() {

		if i == 0 {
			// the name of the graph is on line 0 - can be anything, useful for testing
			graphName = scanner.Text()
		}

		if i == 1 {
			// fill the vertices from line 1
			splitLine := strings.Fields(scanner.Text())
			for _, s := range splitLine {
				n, err := strconv.Atoi(s)
				check(err)
				vertices = append(vertices, n)
			}
		}
		if i == 2 {
			// fill the edges from line 2
			splitLine := strings.Fields(scanner.Text())
			if len(splitLine)%2 != 0 {
				return NewGraph([]int{}, [][2]int{}), "", errors.New("edges line in file must contain even number of digits")
			}
			var v1, v2 int
			for i, vertex := range splitLine {
				n, err := strconv.Atoi(vertex)
				check(err)
				if i%2 == 0 {
					v1 = n
				} else {
					v2 = n
					edges = append(edges, [2]int{v1, v2})
				}
			}

		}
		if i == 3 {
			lineText := scanner.Text()
			if lineText != "!" {
				vertexColours = strings.Fields(lineText)
				if len(vertexColours) != len(vertices) {
					return NewGraph([]int{}, [][2]int{}), "", errors.New("if vertex colours are specified, must be the same number as vertices")
				}
			}
		}
		if i == 4 {
			lineText := scanner.Text()
			if lineText != "!" {
				edgeColours = strings.Fields(lineText)
				if len(edgeColours) != len(edges) {
					return NewGraph([]int{}, [][2]int{}), "", errors.New("if edge colours are specified, must be the same number as edges")
				}
			}
			break // anything after the 5th line of the file should be ignored
		}

		i++
	}

	return NewColourGraph(vertices, edges, vertexColours, edgeColours), graphName, nil
}

// NewGraphFromFile returns a graph from text file input. See NewGraphFromScanner comments for required graph format
func NewGraphFromFile(filePath string) (Graph, string, error) {
	f, err := os.Open(filePath)
	check(err)
	scanner := bufio.NewScanner(f)

	graph, name, graphError := NewGraphFromScanner(scanner)
	closeErr := f.Close()
	check(closeErr)

	return graph, name, graphError
}

// NewGraphFromString returns a graph from text file input. See NewGraphFromScanner comments for required graph format
func NewGraphFromString(graphString string)(Graph, string, error){
	scanner := bufio.NewScanner(strings.NewReader(graphString))
	return NewGraphFromScanner(scanner)
}

// NewGraphOnlyFromString returns a graph from a string, but without a graph name or error
func NewGraphOnlyFromString(graphString string) Graph {
	g, _, _ := NewGraphFromString(graphString)
	return g
}

// InducedSubgraph returns a Graph object which is the subgraph of Graph g induced by vertices in subVertices
// Currently not used
func InducedSubgraph(g *Graph, subVertices []int) (Graph, error) {
	var outGraph Graph
	for _, v := range subVertices {
		if !helpers.Contains(g.Vertices, v) {
			fmt.Println(g.Vertices, v)
			return outGraph, errors.New("subvertices Contains vertices that are not in the Graph g")
		}
	}

	var newEdges [][2]int
	for _, e := range g.Edges {
		if helpers.Contains(subVertices, e[0]) && helpers.Contains(subVertices, e[1]) {
			newEdges = append(newEdges, e)
		}
	}

	outGraph = NewGraph(subVertices, newEdges)
	return outGraph, nil

}


// EdgeAdjacencies returns a map of indexed edge adjacencies, i.e. which edges are related to a given edge
// through sharing a vertex
// TODO: doesn't have a test
func (g *Graph) EdgeAdjacencies() map[int][]int {

	outMap := make(map[int][]int)

	for i, e1 := range g.Edges {
		for j, e2 := range g.Edges {
			if i != j {
				if e1[0] == e2[0] || e1[0] == e2[1] || e1[1] == e2[0] || e1[1] == e2[1] {
					helpers.MapUpdate(i, j, outMap)
				}
			}
		}
	}
	return outMap
}



// ListPairSort takes an [][2]int slice and sorts it, sorting the internal [2]int and then sorting the whole list
// by the first item in the pair
func ListPairSort(l [][2]int) [][2]int {
	var outputSlice [][2]int

	// order the pairs in the list
	for _, pair := range l {
		if pair[0] < pair[1] {
			outputSlice = append(outputSlice, [2]int{pair[0], pair[1]})
		} else {
			outputSlice = append(outputSlice, [2]int{pair[1], pair[0]})
		}
	}

	// order the list by the first of the pairs, or the 2nd if they are equal
	sort.Slice(outputSlice, func(i, j int) bool {
		if outputSlice[i][0] != outputSlice[j][0] {
			return outputSlice[i][0] < outputSlice[j][0]
		} else {

			return outputSlice[i][1] < outputSlice[j][1]
		}
	})

	return outputSlice
}

// GraphEquals checks for equality between two graphs, in that it contains the same list of vertices, and the
// same edges between them. It does not care about the order of vertices or edges, but it does not test for
// isomorphisms, only the same labels and edges between them.
func GraphEquals(g1 *Graph, g2 *Graph) bool {

	// copy vertices to new array and sort
	vert1 := make([]int, len(g1.Vertices))
	vert2 := make([]int, len(g2.Vertices))
	copy(vert1, g1.Vertices)
	copy(vert2, g2.Vertices)
	sort.Ints(vert1)
	sort.Ints(vert2)
	eqVert := reflect.DeepEqual(vert1, vert2)

	// check if vertex and edge colours are equal
	if !checkColoursEqual(g1, g2) {
		return false
	}

	// copy edges and sort
	edge1 := ListPairSort(g1.Edges)
	edge2 := ListPairSort(g2.Edges)
	eqEdge := reflect.DeepEqual(edge1, edge2)

	return eqVert && eqEdge
}

// checkColoursEqual checks if the vertex and edge colours of two graphs are the same
func checkColoursEqual(g1 *Graph, g2 *Graph) bool {
	g1VColoured := len(g1.Vertices) == len(g1.VertexColours)
	g1EColoured := len(g1.Edges) == len(g1.EdgeColours)
	g2VColoured := len(g2.Vertices) == len(g2.VertexColours)
	g2EColoured := len(g2.Edges) == len(g2.EdgeColours)

	// false if the are not both coloured or uncoloured
	if !(g1VColoured == g2VColoured && g1EColoured == g2EColoured) {
		return false
	}

	// Check if vertex colours equal
	if g1VColoured && !reflect.DeepEqual(VertexColourMap(g1), VertexColourMap(g2)) {
		return false
	}

	// check if edge colours equal
	if g1EColoured {
		e1ColMap := orderEdgeColourMap(EdgeColourMap(g1))
		e2ColMap := orderEdgeColourMap(EdgeColourMap(g2))
		if !reflect.DeepEqual(e1ColMap, e2ColMap) {
			return false
		}
	}

	return true

}

// VertexColourMap returns a map of vertices to vertex colours in a graph
func VertexColourMap(g *Graph) map[int]string {
	outMap := make(map[int]string)
	for i, v := range g.Vertices {
		outMap[v] = g.VertexColours[i]
	}
	return outMap
}

// EdgeColourMap returns a map of edges to edge colours in a graph
func EdgeColourMap(g *Graph) map[[2]int]string {
	outMap := make(map[[2]int]string)
	for i, e := range g.Edges {
		outMap[e] = g.EdgeColours[i]
	}
	return outMap
}

// orderEdgeColourMap takes a map of edge colours and orders the keys (edges) so that the edges vertices are in order
// e.g. keys {1, 2} and {2, 1}, which represent the same edge, both become {1, 2}
func orderEdgeColourMap(edgeMap map[[2]int]string) map[[2]int]string {
	outMap := make(map[[2]int]string)
	for k, v := range edgeMap {
		if k[0] < k[1] {
			outMap[k] = v
		} else {
			outMap[[2]int{k[1], k[0]}] = v
		}
	}
	return outMap
}

// GraphPrint returns a string containing some graph information
func GraphPrint(g *Graph) string {
	return fmt.Sprintf("Vertices %v\nEdges %v\nVertexColours %v\nEdgeColours %v ", g.Vertices, g.Edges, g.VertexColours, g.EdgeColours)
}

// GraphIsVertexColoured returns true if the graph is vertex coloured
func GraphIsVertexColoured(g *Graph) bool {
	if len(g.Vertices) == len(g.VertexColours){
		return true
	}
	return false
}

// GraphIsEdgeColoured returns true if the graph is edge coloured
func GraphIsEdgeColoured(g *Graph) bool {
	if len(g.Edges) == len(g.EdgeColours){
		return true
	}
	return false
}

// CopyGraph returns a copy of a graph
func CopyGraph(g *Graph) Graph {
	newVertices := make([]int, len(g.Vertices))
	newEdges := make([][2]int, len(g.Edges))
	newVertexColours := make([]string, len(g.VertexColours))
	newEdgeColours := make([]string, len(g.EdgeColours))

	copy(newVertices, g.Vertices)
	copy(newVertexColours, g.VertexColours)
	copy(newEdgeColours, g.EdgeColours)

	for i, e := range g.Edges {
		newEdges[i] = e
	}

	return NewColourGraph(newVertices, newEdges, newVertexColours, newEdgeColours)


}

---
assembly_go/pkg/assembly/graphstruct_test.go
---
package assembly

import (
	"fmt"
	"io/ioutil"
	"reflect"
	"testing"
)

func TestInducedSubgraph(t *testing.T) {
	tests := []struct {
		g        Graph
		vertices []int
		gNew     Graph
	}{
		{
			NewGraph([]int{0, 1, 2, 3, 4}, [][2]int{{0, 1}, {1, 2}, {2, 3}, {3, 4}}),
			[]int{1, 2, 3},
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}}),
		},
		{
			NewGraph([]int{1, 2, 3, 4, 5}, [][2]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}}),
			[]int{2, 3, 4},
			NewGraph([]int{2, 3, 4}, [][2]int{{2, 3}, {3, 4}}),
		},
		{
			// disconnected graph
			NewGraph([]int{1, 2, 3, 4, 5, 6}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {4, 5}, {5, 6}, {6, 4}}),
			[]int{1, 2, 3, 4, 5},
			NewGraph([]int{1, 2, 3, 4, 5}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {4, 5}}),
		},
		{
			// disconnected graph
			NewGraph([]int{1, 2, 3, 4, 5, 6}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {4, 5}, {5, 6}, {6, 4}}),
			[]int{1, 2, 4, 5},
			NewGraph([]int{1, 2, 4, 5}, [][2]int{{1, 2}, {4, 5}}),
		},
	}

	for _, tt := range tests {

		gNew, err := InducedSubgraph(&tt.g, tt.vertices)

		if err != nil {
			t.Log("Error returned", err)
		}

		eq1 := reflect.DeepEqual(gNew.Vertices, tt.gNew.Vertices)
		eq2 := reflect.DeepEqual(gNew.Edges, tt.gNew.Edges)
		if !(eq1 && eq2) {
			t.Errorf("Induced Subgraph Error:\n"+
				"Expected %v %v"+
				"Got %v %v",
				tt.gNew.Vertices, tt.gNew.Edges, gNew.Vertices, gNew.Edges)
		}
	}
}

func TestNewGraphFromFile(t *testing.T) {
	tests := []struct {
		fileName      string
		vertices      []int
		edges         [][2]int
		vertexColours []string
		edgeColours   []string
		name          string
	}{
		{
			"testdata/graphs/triangle.txt",
			[]int{0, 1, 2},
			[][2]int{{0, 1}, {1, 2}, {2, 0}},
			[]string{},
			[]string{},
			"Triangle Graph (uncoloured)",
		},
		{
			"testdata/graphs/square_coloured.txt",
			[]int{1, 2, 3, 4},
			[][2]int{{1, 2}, {2, 3}, {3, 4}, {4, 1}},
			[]string{"Red", "Blue", "Red", "Blue"},
			[]string{"A", "B", "B", "A"},
			"Square Graph (coloured)",
		},
	}

	for _, tt := range tests {
		g, name, err := NewGraphFromFile(tt.fileName)
		check(err)
		eq1 := name == tt.name
		eq2 := reflect.DeepEqual(g.Vertices, tt.vertices)
		eq3 := reflect.DeepEqual(g.Edges, tt.edges)
		eq4 := reflect.DeepEqual(g.VertexColours, tt.vertexColours)
		eq5 := reflect.DeepEqual(g.EdgeColours, tt.edgeColours)
		if !(eq1 && eq2 && eq3 && eq4 && eq5) {
			errString := "NewGraphFromFile error:\n"
			errString += fmt.Sprintf("Description expected %v, got %v - %v\n", tt.name, name, eq1)
			errString += fmt.Sprintf("Vertices expected %v, got %v - %v\n", tt.vertices, g.Vertices, eq2)
			errString += fmt.Sprintf("Edges expected %v, got %v - %v\n", tt.edges, g.Edges, eq3)
			errString += fmt.Sprintf("Vertex Colours expected %v, got %v - %v\n", tt.vertexColours, g.VertexColours, eq4)
			errString += fmt.Sprintf("Edge Colours expected %v, got %v - %v\n", tt.edgeColours, g.EdgeColours, eq5)
			t.Error(errString)
		}
	}
}

func TestNewGraphFromString(t *testing.T) {
	tests := []struct {
		fileName      string
		vertices      []int
		edges         [][2]int
		vertexColours []string
		edgeColours   []string
		name          string
	}{
		{
			"testdata/graphs/triangle.txt",
			[]int{0, 1, 2},
			[][2]int{{0, 1}, {1, 2}, {2, 0}},
			[]string{},
			[]string{},
			"Triangle Graph (uncoloured)",
		},
		{
			"testdata/graphs/square_coloured.txt",
			[]int{1, 2, 3, 4},
			[][2]int{{1, 2}, {2, 3}, {3, 4}, {4, 1}},
			[]string{"Red", "Blue", "Red", "Blue"},
			[]string{"A", "B", "B", "A"},
			"Square Graph (coloured)",
		},
	}

	for _, tt := range tests {

		// extract string from file
		graphBytes, _ := ioutil.ReadFile(tt.fileName)
		graphString := string(graphBytes)

		g, name, err := NewGraphFromString(graphString)
		check(err)
		eq1 := name == tt.name
		eq2 := reflect.DeepEqual(g.Vertices, tt.vertices)
		eq3 := reflect.DeepEqual(g.Edges, tt.edges)
		eq4 := reflect.DeepEqual(g.VertexColours, tt.vertexColours)
		eq5 := reflect.DeepEqual(g.EdgeColours, tt.edgeColours)
		if !(eq1 && eq2 && eq3 && eq4 && eq5) {
			errString := "NewGraphFromFile error:\n"
			errString += fmt.Sprintf("Description expected %v, got %v - %v\n", tt.name, name, eq1)
			errString += fmt.Sprintf("Vertices expected %v, got %v - %v\n", tt.vertices, g.Vertices, eq2)
			errString += fmt.Sprintf("Edges expected %v, got %v - %v\n", tt.edges, g.Edges, eq3)
			errString += fmt.Sprintf("Vertex Colours expected %v, got %v - %v\n", tt.vertexColours, g.VertexColours, eq4)
			errString += fmt.Sprintf("Edge Colours expected %v, got %v - %v\n", tt.edgeColours, g.EdgeColours, eq5)
			t.Error(errString)
		}
	}
}

func TestNewGraphOnlyFromString(t *testing.T) {
	tests := []struct {
		fileName      string
		vertices      []int
		edges         [][2]int
		vertexColours []string
		edgeColours   []string
	}{
		{
			"testdata/graphs/triangle.txt",
			[]int{0, 1, 2},
			[][2]int{{0, 1}, {1, 2}, {2, 0}},
			[]string{},
			[]string{},
		},
		{
			"testdata/graphs/square_coloured.txt",
			[]int{1, 2, 3, 4},
			[][2]int{{1, 2}, {2, 3}, {3, 4}, {4, 1}},
			[]string{"Red", "Blue", "Red", "Blue"},
			[]string{"A", "B", "B", "A"},
		},
	}

	for _, tt := range tests {

		// extract string from file
		graphBytes, _ := ioutil.ReadFile(tt.fileName)
		graphString := string(graphBytes)

		g := NewGraphOnlyFromString(graphString)

		eq1 := reflect.DeepEqual(g.Vertices, tt.vertices)
		eq2 := reflect.DeepEqual(g.Edges, tt.edges)
		eq3 := reflect.DeepEqual(g.VertexColours, tt.vertexColours)
		eq4 := reflect.DeepEqual(g.EdgeColours, tt.edgeColours)
		if !(eq1 && eq2 && eq3 && eq4) {
			errString := "NewGraphFromFile error:\n"
			errString += fmt.Sprintf("Vertices expected %v, got %v - %v\n", tt.vertices, g.Vertices, eq1)
			errString += fmt.Sprintf("Edges expected %v, got %v - %v\n", tt.edges, g.Edges, eq2)
			errString += fmt.Sprintf("Vertex Colours expected %v, got %v - %v\n", tt.vertexColours, g.VertexColours, eq3)
			errString += fmt.Sprintf("Edge Colours expected %v, got %v - %v\n", tt.edgeColours, g.EdgeColours, eq4)
			t.Error(errString)
		}
	}
}

func TestListPairSort(t *testing.T) {
	tests := []struct {
		input  [][2]int
		output [][2]int
	}{
		{
			[][2]int{{1, 2}, {3, 4}, {5, 6}},
			[][2]int{{1, 2}, {3, 4}, {5, 6}},
		},
		{
			[][2]int{{1, 2}, {5, 6}, {3, 4}},
			[][2]int{{1, 2}, {3, 4}, {5, 6}},
		},
		{
			[][2]int{{2, 1}, {6, 5}, {4, 3}},
			[][2]int{{1, 2}, {3, 4}, {5, 6}},
		},
		{
			[][2]int{{6, 5}, {1, 2}, {4, 3}},
			[][2]int{{1, 2}, {3, 4}, {5, 6}},
		},
		{
			[][2]int{{1, 8}, {1, 7}},
			[][2]int{{1, 7}, {1, 8}},
		},
	}

	for _, tt := range tests {
		output := ListPairSort(tt.input)
		eq := reflect.DeepEqual(output, tt.output)
		if !eq {
			t.Errorf("LisPairSort error, input %v, expected %v, got %v",
				tt.input, tt.output, output)
		}
	}
}

func TestGraphEquals(t *testing.T) {
	tests := []struct {
		g1 Graph
		g2 Graph
		eq bool
	}{
		{ //0
			NewGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 4}}),
			NewGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 4}}),
			true,
		},
		{ //1
			NewGraph([]int{3, 2, 1}, [][2]int{{2, 3}, {2, 1}, {1, 3}}),
			NewGraph([]int{1, 2, 3}, [][2]int{{1, 2}, {2, 3}, {3, 1}}),
			true,
		},
		{ //2
			NewGraph([]int{3, 2, 1, 4}, [][2]int{{2, 3}, {2, 1}, {1, 3}, {4, 3}}),
			NewGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {3, 4}}),
			true,
		},
		{ //3
			NewGraph([]int{3, 2, 1, 4}, [][2]int{{2, 3}, {2, 1}, {1, 3}, {1, 4}}),
			NewGraph([]int{1, 2, 3, 4}, [][2]int{{1, 2}, {2, 3}, {3, 1}, {3, 4}}),
			false,
		},
		{ //4
			NewColourGraph([]int{3, 2, 1, 4},
				[][2]int{{2, 3}, {2, 1}, {1, 3}, {1, 4}},
				[]string{"A", "B", "A", "B"},
				[]string{"A", "B", "A", "B"}),
			NewColourGraph([]int{1, 2, 3, 4},
				[][2]int{{1, 2}, {2, 3}, {3, 1}, {3, 4}},
				[]string{"A", "B", "A", "B"},
				[]string{"A", "B", "A", "B"}),
			false,
		},
		{ //5
			NewColourGraph([]int{3, 2, 1, 4},
				[][2]int{{2, 3}, {2, 1}, {1, 3}, {1, 4}},
				[]string{"A", "B", "A", "B"},
				[]string{"A", "B", "A", "B"}),
			NewColourGraph([]int{1, 2, 3, 4},
				[][2]int{{1, 2}, {2, 3}, {3, 1}, {1, 4}},
				[]string{"A", "B", "A", "B"},
				[]string{"B", "A", "A", "B"}),
			true,
		},
		{ //6
			NewColourGraph([]int{3, 2, 1, 4},
				[][2]int{{2, 3}, {2, 1}, {1, 3}, {1, 4}},
				[]string{"A", "B", "A", "B"},
				[]string{"A", "B", "A", "B"}),
			NewColourGraph([]int{1, 2, 3, 4},
				[][2]int{{1, 2}, {2, 3}, {3, 1}, {1, 4}},
				[]string{"A", "B", "B", "A"}, // not equal
				[]string{"A", "B", "A", "B"}),
			false,
		},
		{ //7
			NewColourGraph([]int{3, 2, 1, 4},
				[][2]int{{2, 3}, {2, 1}, {1, 3}, {1, 4}}, // [1 2][1 3][1 4][2 3]
				[]string{"A", "B", "A", "B"},             // 1:A, 2:B, 3:A, 4:B
				[]string{"A", "B", "A", "B"}),            // [1 2]:B, [1 3]:A, [1 4]:B, [2 3]:A,
			NewColourGraph([]int{1, 2, 3, 4},
				[][2]int{{1, 2}, {2, 3}, {3, 1}, {1, 4}}, // [1 2][1 3][1 4][2 3]
				[]string{"A", "B", "A", "B"},             // 1:A, 2:B, 3:A, 4:B
				[]string{"A", "B", "B", "A"}),            // [1 2]:A, [1 3]:B, [1 4]:A, [2 3]:B
			false,
		},
		{ //8
			NewColourGraph([]int{3, 2, 1, 4},
				[][2]int{{2, 3}, {2, 1}, {1, 3}, {1, 4}},
				[]string{"A", "B", "A", "B"},
				[]string{"A", "B", "A", "B"}),
			NewColourGraph([]int{1, 2, 3, 4},
				[][2]int{{1, 2}, {2, 3}, {3, 1}, {1, 4}},
				[]string{"A", "B", "B", "A"},  // not equal
				[]string{"A", "B", "B", "A"}), // not equal
			false,
		},
	}

	for i, tt := range tests {
		eq := GraphEquals(&tt.g1, &tt.g2)
		if eq != tt.eq {
			errStr := fmt.Sprintf("GraphEquals error on test %v:\n", i)
			errStr += fmt.Sprintf(GraphPrint(&tt.g1) + "\n")
			errStr += fmt.Sprintf(GraphPrint(&tt.g2) + "\n")
			errStr += fmt.Sprintf("Expected %v got %v", tt.eq, eq)
			t.Error(errStr)
		}
	}
}

func TestVertexColourMap(t *testing.T) {
	tests := []struct {
		g Graph
		m map[int]string
	}{
		{NewColourGraph([]int{1, 2, 3, 4},
			[][2]int{{1, 2}, {2, 3}, {3, 4}},
			[]string{"A", "A", "A", "B"},
			[]string{}),
			map[int]string{
				1: "A",
				2: "A",
				3: "A",
				4: "B",
			},
		},
	}

	for _, tt := range tests {
		m := VertexColourMap(&tt.g)
		eq := reflect.DeepEqual(tt.m, m)
		if !eq {
			t.Errorf("VertexColourMap Error\nGraph %v %v %v %v\nExpected %v\nGot %v",
				tt.g.Vertices, tt.g.Edges, tt.g.VertexColours, tt.g.EdgeColours, tt.m, m)
		}
	}
}

func TestEdgeColourMap(t *testing.T) {
	tests := []struct {
		g Graph
		m map[[2]int]string
	}{
		{NewColourGraph([]int{1, 2, 3, 4},
			[][2]int{{1, 2}, {2, 3}, {3, 4}},
			[]string{},
			[]string{"A", "A", "B"}),
			map[[2]int]string{
				[2]int{1, 2}: "A",
				[2]int{2, 3}: "A",
				[2]int{3, 4}: "B",
			},
		},
	}

	for _, tt := range tests {
		m := EdgeColourMap(&tt.g)
		eq := reflect.DeepEqual(tt.m, m)
		if !eq {
			t.Errorf("VertexColourMap Error\nGraph %v %v %v %v\nExpected %v\nGot %v",
				tt.g.Vertices, tt.g.Edges, tt.g.VertexColours, tt.g.EdgeColours, tt.m, m)
		}
	}
}

func TestCopyGraph(t *testing.T) {
	tests := []Graph{
		NewGraphOnlyFromFile("testdata/graphs/fish_graph.txt"),
		NewGraphOnlyFromFile("testdata/graphs/square.txt"),
		NewGraphOnlyFromFile("testdata/graphs/square_coloured.txt"),
		NewGraphOnlyFromFile("testdata/graphs/triangle.txt"),
	}
	for i, graph := range tests {
		newGraph := CopyGraph(&graph)
		if !GraphEquals(&graph, &newGraph) {
			t.Errorf("CopyGraph error, test %v\nInput graph %v\nCopied Graph %v", i, graph, newGraph)
		}
	}
}


---
assembly_go/pkg/assembly/logger.go
---
package assembly

import (
	"log"
	"os"
)

// This file defines the logger struct and instantiates a global logger

type BuiltinLogger struct {
	logger *log.Logger
}

func NewBuiltinLogger() *BuiltinLogger {
	return &BuiltinLogger{logger: log.New(os.Stdout, "", 5)}
}

func (l *BuiltinLogger) Debug(args ...interface{}) {
	l.logger.Println(args...)
}

func (l *BuiltinLogger) Debugf(format string, args ...interface{}) {
	l.logger.Printf(format, args...)
}

func (l *BuiltinLogger) SetOutput(f *os.File){
	l.logger.SetOutput(f)
}

var Logger = NewBuiltinLogger()

---
assembly_go/pkg/assembly/molecules.go
---
package assembly

import (
	"GoAssembly/pkg/helpers"
	"bufio"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

// Code relating specifically to parsing molecules from mol files / mol blocks


func MolColourGraph(molFile string) Graph {
	atomTypes, bonds, bondTypes, atomIndices := ParseMolFile(molFile, true)
	bondTypeString := make([]string, len(bondTypes))
	for i, bondType := range bondTypes{
		switch bondType {
		case 1:
			bondTypeString[i] = "single"
		case 2:
			bondTypeString[i] = "double"
		case 3:
			bondTypeString[i] = "triple"
		case 4:
			bondTypeString[i] = "aromatic"
		default:
			bondTypeString[i] = "error"
		}

	}
	outGraph := NewColourGraph(atomIndices, bonds, atomTypes, bondTypeString)
	return outGraph
}


func MolBlockColourGraph(molBlock string) Graph {
	// TODO: refactor code reuse with MolColourGraph
	// TODO: ParseMolString should not always be true
	atomTypes, bonds, bondTypes, atomIndices := ParseMolString(molBlock, true)
	bondTypeString := make([]string, len(bondTypes))
	for i, bondType := range bondTypes{
		switch bondType {
		case 1:
			bondTypeString[i] = "single"
		case 2:
			bondTypeString[i] = "double"
		case 3:
			bondTypeString[i] = "triple"
		case 4:
			bondTypeString[i] = "aromatic"
		default:
			bondTypeString[i] = "error"
		}

	}
	outGraph := NewColourGraph(atomIndices, bonds, atomTypes, bondTypeString)
	return outGraph
}
// ParseMultiMolString parses string input that is in the form of an sdfile, i.e. a sequence of mol blocks with $$$$ as delimiter
func ParseMultiMolString(multiMolString string, stripH bool) []Graph {
	multiMolString = strings.ReplaceAll(multiMolString, "\r\n", "\n")  // deal with windows insertion of carriage return
	mols := strings.Split(multiMolString, "$$$$\n")
	var molGraphs []Graph
	for _, mol := range mols{
		molGraph := MolBlockColourGraph(mol)
		if len(molGraph.Vertices) != 0 {
			molGraphs = append(molGraphs, molGraph)
		}
	}
	return molGraphs
}


func MolListToPathway(mols []Graph, duplicates []Duplicates) (Graph, Pathway){
	// TODO: validate inputs
	originalGraph := mols[0]
	pathway := Pathway{
			mols[1:len(mols)-1],
			mols[len(mols)-1],
			duplicates,
		[][]int{},
	}

	return originalGraph, pathway

}

func ParseSDFile(filePath string, stripH bool) []Graph {
	fileBytes, _ := ioutil.ReadFile(filePath)
	fileString := string(fileBytes)
	return ParseMultiMolString(fileString, stripH)
}

func ParseMolScanner(scanner *bufio.Scanner, stripH bool)([]string, [][2]int, []int, []int){
	var atoms []string
	var atomIndices []int
	var bonds [][2]int
	var bondTypes []int

	i := 0
	atNum := 0
	var atomEnd, bondEnd int
	for scanner.Scan() {
		if i == 3 {
			line3 := scanner.Text()

			atomString := strings.ReplaceAll(line3[:3], " ", "")
			bondString := strings.ReplaceAll(line3[3:6], " ", "")

			atoms, err := strconv.Atoi(atomString)
			check(err)
			bonds, err := strconv.Atoi(bondString)
			check(err)

			atomEnd = 4 + atoms
			bondEnd = atomEnd + bonds

		}

		// atom block
		if i >= 4 && i < atomEnd {
			line := strings.Fields(scanner.Text())
			atoms = append(atoms, line[3])

			atomIndices = append(atomIndices, atNum)
			atNum++
		}

		// bond block
		if i >= atomEnd && i < bondEnd {

			bondLine := scanner.Text()
			at1String := strings.ReplaceAll(bondLine[:3], " ", "")
			at2String := strings.ReplaceAll(bondLine[3:6], " ", "")
			typeString := strings.ReplaceAll(bondLine[6:9], " ", "")

			// line := strings.Fields(scanner.Text())
			at1, err := strconv.Atoi(at1String)
			check(err)
			at2, err := strconv.Atoi(at2String)
			check(err)
			bondType, err := strconv.Atoi(typeString)
			check(err)
			bonds = append(bonds, [2]int{at1 - 1, at2 - 1}) // -1 as changing to zero indexing
			bondTypes = append(bondTypes, bondType)

		}

		i++
	}


	if stripH{
		return stripHAtoms(atoms, bonds, bondTypes, atomIndices)
	} else {
		return atoms, bonds, bondTypes, atomIndices
	}
}

// ParseMolFile extracts lists of atoms, bonds, bond types from a mol file
func ParseMolFile(filePath string, stripH bool) ([]string, [][2]int, []int, []int) {
	f, err := os.Open(filePath)
	check(err)
	scanner := bufio.NewScanner(f)
	atoms, bonds, bondTypes, atomIndices := ParseMolScanner(scanner, stripH)

	cErr := f.Close()
	check(cErr)

	return atoms, bonds, bondTypes, atomIndices

}

// ParseMolString extracts lists of atoms, bonds, bond types from a string of a mol block
func ParseMolString(molString string, stripH bool)([]string, [][2]int, []int, []int){
	scanner := bufio.NewScanner(strings.NewReader(molString))
	atoms, bonds, bondTypes, atomIndices := ParseMolScanner(scanner, stripH)
	return atoms, bonds, bondTypes, atomIndices
}

// stripHAtoms takes out all the H atoms, while maintaining the correct connectivity etc
func stripHAtoms(atoms []string, bonds [][2] int, bondTypes []int, atomIndices []int)([]string, [][2]int, []int, []int){
		atomMap := make(map[int]int)
		var newAtoms []string
		var newBonds [][2]int
		var newBondTypes []int
		var newAtomIndices []int
		var HIndices []int

		// update atoms
		newInd := 0
		for i := 0; i < len(atoms); i++{
			if atoms[i] != "H" {
				atomMap[atomIndices[i]] = newInd
				newAtomIndices = append(newAtomIndices, newInd)
				newAtoms = append(newAtoms, atoms[i])
				newInd++
			} else {
				HIndices = append(HIndices, atomIndices[i])
			}
		}

		// update bonds
		for i, b := range bonds{
			at1 := b[0]
			at2 := b[1]
			if !helpers.Contains(HIndices, at1) && !helpers.Contains(HIndices, at2){
				newBonds = append(newBonds, [2]int{atomMap[at1], atomMap[at2]})
				newBondTypes = append(newBondTypes, bondTypes[i])
			}
		}

		return newAtoms, newBonds, newBondTypes, newAtomIndices
}




---
assembly_go/pkg/assembly/molecules_test.go
---
package assembly

import (
	"fmt"
	"io/ioutil"
	"reflect"
	"testing"
)

func TestParseMolFile(t *testing.T) {

	var tests = []struct {
		fileName             string
		atomsH, atomsNoH     []string
		bondsH, bondsNoH     [][2]int
		atomIndH, atomIndNoH []int
		bondTH, bondTNoH     []int
	}{
		{
			"testdata/formic_acid_with_H.mol",
			[]string{"C", "O", "O", "H", "H"},
			[]string{"C", "O", "O"},
			[][2]int{{0, 1}, {0, 2}, {0, 3}, {2, 4}},
			[][2]int{{0, 1}, {0, 2}},
			[]int{0, 1, 2, 3, 4},
			[]int{0, 1, 2},
			[]int{2, 1, 1, 1},
			[]int{2, 1},
		},
		{
			"testdata/big_mol_test.mol",
			[]string{"C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","Br","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H","H"},
			[]string{"C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","C","Br"},
			[][2]int{{0, 1},{1, 2},{2, 3},{3, 4},{4, 5},{5, 6},{6, 7},{7, 8},{8, 9},{9, 10},{10, 11},{11, 12},{12, 13},{13, 14},{14, 15},{15, 16},{16, 17},{17, 18},{18, 19},{19, 20},{20, 21},{21, 22},{22, 23},{23, 24},{24, 25},{25, 26},{26, 27},{27, 28},{28, 29},{29, 30},{30, 31},{31, 32},{32, 33},{33, 34},{34, 35},{35, 36},{36, 37},{37, 38},{38, 39},{39, 40},{0, 41},{0, 42},{1, 43},{2, 44},{2, 45},{3, 46},{3, 47},{4, 48},{4, 49},{5, 50},{5, 51},{6, 52},{6, 53},{7, 54},{7, 55},{8, 56},{8, 57},{9, 58},{9, 59},{10, 60},{10, 61},{11, 62},{11, 63},{12, 64},{12, 65},{13, 66},{13, 67},{14, 68},{14, 69},{15, 70},{15, 71},{16, 72},{16, 73},{17, 74},{17, 75},{18, 76},{18, 77},{19, 78},{19, 79},{20, 80},{20, 81},{21, 82},{21, 83},{22, 84},{22, 85},{23, 86},{23, 87},{24, 88},{24, 89},{25, 90},{25, 91},{26, 92},{26, 93},{27, 94},{27, 95},{28, 96},{28, 97},{29, 98},{29, 99},{30, 100},{30, 101},{31, 102},{31, 103},{32, 104},{32, 105},{33, 106},{33, 107},{34, 108},{34, 109},{35, 110},{35, 111},{36, 112},{36, 113},{37, 114},{37, 115},{38, 116},{38, 117},{39, 118},{39, 119}},
			[][2]int{{0, 1},{1, 2},{2, 3},{3, 4},{4, 5},{5, 6},{6, 7},{7, 8},{8, 9},{9, 10},{10, 11},{11, 12},{12, 13},{13, 14},{14, 15},{15, 16},{16, 17},{17, 18},{18, 19},{19, 20},{20, 21},{21, 22},{22, 23},{23, 24},{24, 25},{25, 26},{26, 27},{27, 28},{28, 29},{29, 30},{30, 31},{31, 32},{32, 33},{33, 34},{34, 35},{35, 36},{36, 37},{37, 38},{38, 39},{39, 40}},
			[]int{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119},
			[]int{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40},
			[]int{2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
			[]int{2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		},
	}

	for _, tt := range tests {
		atomsH, bondsH, bondTH, atomIndH := ParseMolFile(tt.fileName, false)
		atomsNoH, bondsNoH, bondTNoH, atomIndNoH := ParseMolFile(tt.fileName, true)

		var err = false
		var errString string
		if !reflect.DeepEqual(atomsH, tt.atomsH){
			err = true
			errString += fmt.Sprintf("Atoms with H expecte %v got %v\n", tt.atomsH, atomsH)
		}
		if !reflect.DeepEqual(bondsH, tt.bondsH){
			err = true
			errString += fmt.Sprintf("Bonds with H expected %v got %v\n", tt.bondsH, bondsH)
		}
		if !reflect.DeepEqual(atomIndH, tt.atomIndH){
			err = true
			errString += fmt.Sprintf("Atom Indices with H expected %v got %v\n", tt.atomIndH, atomIndH)
		}
		if !reflect.DeepEqual(bondTH, tt.bondTH){
			err = true
			errString += fmt.Sprintf("Bond Types with H expected %v got %v\n", tt.bondTH, bondTH)
		}
		if !reflect.DeepEqual(atomsNoH, tt.atomsNoH){
			err = true
			errString += fmt.Sprintf("Atoms without H expected %v got %v\n", tt.atomsNoH, atomsNoH)
		}
		if !reflect.DeepEqual(bondsNoH, tt.bondsNoH){
			err = true
			errString += fmt.Sprintf("Bonds without H expected %v got %v\n", tt.bondsNoH, bondsNoH)
		}
		if !reflect.DeepEqual(atomIndNoH, tt.atomIndNoH){
			err = true
			errString += fmt.Sprintf("Atom Indices without H expected %v got %v\n", tt.atomIndNoH, atomIndNoH)
		}
		if !reflect.DeepEqual(bondTNoH, tt.bondTNoH){
			err = true
			errString += fmt.Sprintf("Bond Types without H expected %v got %v\n", tt.bondTNoH, bondTNoH)
		}
		if err {
			t.Error(errString)
		}
	}

}

func TestParseMolString(t *testing.T) {

	var tests = []struct {
		fileName             string
		atomsH, atomsNoH     []string
		bondsH, bondsNoH     [][2]int
		atomIndH, atomIndNoH []int
		bondTH, bondTNoH     []int
	}{
		{
			"testdata/formic_acid_with_H.mol",
			[]string{"C", "O", "O", "H", "H"},
			[]string{"C", "O", "O"},
			[][2]int{{0, 1}, {0, 2}, {0, 3}, {2, 4}},
			[][2]int{{0, 1}, {0, 2}},
			[]int{0, 1, 2, 3, 4},
			[]int{0, 1, 2},
			[]int{2, 1, 1, 1},
			[]int{2, 1},
		},
	}

	for _, tt := range tests {

		molBytes, _ := ioutil.ReadFile(tt.fileName)
		molString := string(molBytes)

		atomsH, bondsH, bondTH, atomIndH := ParseMolString(molString, false)
		atomsNoH, bondsNoH, bondTNoH, atomIndNoH := ParseMolString(molString, true)

		var err = false
		var errString string
		if !reflect.DeepEqual(atomsH, tt.atomsH){
			err = true
			errString += fmt.Sprintf("Atoms with H expecte %v got %v\n", tt.atomsH, atomsH)
		}
		if !reflect.DeepEqual(bondsH, tt.bondsH){
			err = true
			errString += fmt.Sprintf("Bonds with H expected %v got %v\n", tt.bondsH, bondsH)
		}
		if !reflect.DeepEqual(atomIndH, tt.atomIndH){
			err = true
			errString += fmt.Sprintf("Atom Indices with H expected %v got %v\n", tt.atomIndH, atomIndH)
		}
		if !reflect.DeepEqual(bondTH, tt.bondTH){
			err = true
			errString += fmt.Sprintf("Bond Types with H expected %v got %v\n", tt.bondTH, bondTH)
		}
		if !reflect.DeepEqual(atomsNoH, tt.atomsNoH){
			err = true
			errString += fmt.Sprintf("Atoms without H expected %v got %v\n", tt.atomsNoH, atomsNoH)
		}
		if !reflect.DeepEqual(bondsNoH, tt.bondsNoH){
			err = true
			errString += fmt.Sprintf("Bonds without H expected %v got %v\n", tt.bondsNoH, bondsNoH)
		}
		if !reflect.DeepEqual(atomIndNoH, tt.atomIndNoH){
			err = true
			errString += fmt.Sprintf("Atom Indices without H expected %v got %v\n", tt.atomIndNoH, atomIndNoH)
		}
		if !reflect.DeepEqual(bondTNoH, tt.bondTNoH){
			err = true
			errString += fmt.Sprintf("Bond Types without H expected %v got %v\n", tt.bondTNoH, bondTNoH)
		}
		if err {
			t.Error(errString)
		}
	}

}

func TestParseMultiMolString(t *testing.T) {
	fileName := "testdata/dual_ring_test.sdf"
	molBytes, _ := ioutil.ReadFile(fileName)
	molString := string(molBytes)

	molGraphs := ParseMultiMolString(molString, true)

	for _, g := range molGraphs{
		fmt.Println(g)
	}
}

func TestParseSDFile(t *testing.T) {
	fileName := "testdata/dual_ring_test.sdf"
	molGraphs:= ParseSDFile(fileName, true)
	for _, g := range molGraphs{
		fmt.Println(g)
	}

}


func TestMolListToPathway(t *testing.T) {
	fileName := "testdata/taxol_test.sdf"
	molGraphs:= ParseSDFile(fileName, true)
	originalGraph, pathway := MolListToPathway(molGraphs,[]Duplicates{})

	fmt.Println("Original Graph")
	fmt.Println(originalGraph)
	fmt.Println("Pathway")
	fmt.Println(PathwayString(&pathway))


	fmt.Println("**********************")

	assemblyPathway := AssemblyPathway(originalGraph, pathway, 100, 500, "shortest")

	fmt.Println("RESULTING PATHWAY")
	fmt.Println(PathwayString(&assemblyPathway[0]))
	fmt.Println("Assembly Index")
	fmt.Println(AssemblyIndex(&assemblyPathway[0], &originalGraph))
}

---
assembly_go/pkg/assembly/testdata/aspirin.mol.txt
---
﻿Assembly Pathways Depth-First Search
Main Object
InChI=1/C9H8O4/c1-6(10)13-8-5-3-2-4-7(8)9(11)12/h2-5H,1H3,(H,11,12)/f/h11H

Shortest Pathways
=================
InChI=1/C3H6/c1-3-2/h3H,1H2,2H3


InChI=1/C2H4O2/c1-2(3)4/h1H3,(H,3,4)/f/h3H


InChI=1/C3H6/c1-3-2/h3H,1H2,2H3


=================
InChI=1/C3H6/c1-3-2/h3H,1H2,2H3


InChI=1/C2H4O2/c1-2(3)4/h1H3,(H,3,4)/f/h3H


InChI=1/C2H6O/c1-2-3/h3H,2H2,1H3


Assembly Index 8


---
assembly_go/pkg/assembly/testdata/graphs/a_test_1.txt
---
Aspirin substructure error test 1
0 1 2
0 1 1 2
O C O
single double

---
assembly_go/pkg/assembly/testdata/graphs/a_test_2.txt
---
Aspirin substructure error test 2
3 10 11
3 10 10 11
O C O
single double

---
assembly_go/pkg/assembly/testdata/graphs/chain16.txt
---
A chain of 16 vertices
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17
!
!

---
assembly_go/pkg/assembly/testdata/graphs/edge_colour_fail_test.txt
---
Edge Colour Graph Failure Test
4 6 2 7 3 8 1 9 5 10
1 2 1 9 2 7 3 8 4 6 5 10 6 7 6 9 7 8 7 10
C0 C1 B0 B1 B0 B1 C0 C1 C0 C1
!

---
assembly_go/pkg/assembly/testdata/graphs/fish_graph.txt
---
Fish Graph - Full
1 2 3 4 5 6 7 8 9 10
1 3 2 3 3 4 4 7 7 8 8 9 4 5 5 6 6 9 9 10
A A B A A B B B A A
X Y X X X Y X X Y X

---
assembly_go/pkg/assembly/testdata/graphs/fish_graph_remnant.txt
---
Fish Graph - remnant
6 9 8 10
8 9 6 9 9 10
B A B A
Y Y X

---
assembly_go/pkg/assembly/testdata/graphs/fish_graph_split1.txt
---
Fish Graph - Split 1
1 2 3 4
1 3 2 3 3 4
A A B A
X Y X

---
assembly_go/pkg/assembly/testdata/graphs/fish_graph_split2.txt
---
Fish Graph - Split 2
4 7 8 5 6
4 7 7 8 4 5 5 6
A B B A B
X X X X

---
assembly_go/pkg/assembly/testdata/graphs/hexagon.txt
---
Hexagon Uncoloured
1 2 3 4 5 6
1 2 2 3 3 4 4 5 5 6 6 1
!
!

---
assembly_go/pkg/assembly/testdata/graphs/nine_grid.txt
---
Grid of nine points
1 2 3 4 5 6 7 8 9
1 2 2 3 4 5 5 6 7 8 8 9 1 4 4 7 2 5 5 8 3 6 6 9
!
!

---
assembly_go/pkg/assembly/testdata/graphs/not_square.txt
---
Square Graph
1 2 3 4
1 2 2 3 2 4 3 4
!
!

---
assembly_go/pkg/assembly/testdata/graphs/square.txt
---
Square Graph
1 2 3 4
1 2 2 3 3 4 4 1
!
!

---
assembly_go/pkg/assembly/testdata/graphs/square_coloured.txt
---
Square Graph (coloured)
1 2 3 4
1 2 2 3 3 4 4 1
Red Blue Red Blue
A B B A

---
assembly_go/pkg/assembly/testdata/graphs/square_coloured_isomorphic.txt
---
Square Graph (coloured)
1 2 3 4
1 3 3 2 2 4 4 1
Red Red Blue Blue
A B B A

---
assembly_go/pkg/assembly/testdata/graphs/square_coloured_relabeled.txt
---
Square Graph (coloured)
0 1 2 3
0 1 1 2 2 3 3 0
Red Blue Red Blue
A B B A

---
assembly_go/pkg/assembly/testdata/graphs/square_isomorph.txt
---
Square Graph
1 2 3 4
1 3 3 2 2 4 4 1
!
!

---
assembly_go/pkg/assembly/testdata/graphs/triangle.txt
---
Triangle Graph (uncoloured)
0 1 2
0 1 1 2 2 0
!
!

---
assembly_go/pkg/assembly/testdata/graphs/triangle_bk_x.txt
---
Triangle Graph (uncoloured)
0 1 2
0 1 1 2 2 1
!
!

---
assembly_go/pkg/assembly/testdata/graphs/two_joined_squares.txt
---
Two squares joined by a single edge
0 1 2 3 4 5 6 7
0 1 0 2 1 3 2 3 3 4 4 5 4 6 5 7 6 7
C C C C C C C C
S S S S S S S S S

---
assembly_go/pkg/assembly/testdata/pathways/square_starting_pathway.txt
---


---
assembly_go/pkg/assembly/testdata/pathways/test_pathway.txt
---
!PATHWAY
square.txt
!REMNANT
square.txt
square.txt
!DUPLICATES
0 1
1 2

---
